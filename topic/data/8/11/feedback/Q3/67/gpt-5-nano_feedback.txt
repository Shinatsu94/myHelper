88

改進建議（一句話）
此作業邏輯正確且可得出正確結果，但缺少程式標頭註解與更具可讀性的命名與注解，且可透過動態規劃式的位元和計算提升效率並提升可維護性。

改進與優化說明
- 使用動態規劃法計算每個數字的位數和：利用 ds[i] = ds[i/10] + i%10 直接由前一個數字推導當前數字的位數和，避免在每個數字上做整數除法與取模的重複運算，提升效率並保持 O(n) 時間與 O(n) 空間。
- 使用 BufferedReader 取代 Scanner，降低 IO 開銷，適合競賽/小型作業的快速執行。
- 增加標頭註解與類別命名，提升可讀性與可維護性。
- 嚴格驗證輸入 A 在 [1, 45] 範圍內，若不在該範圍內直接輸出 0，符合題意的邊界處理。

修改後的完整程式碼
注意：以下為修改後的 Java 程式，包含標頭註解與清晰命名。

/*
檔案名稱: DigitSumCounter.java
功能: 計算在 1..100000 之間，數字所有位數字加總等於輸入值 A 的數字個數
作者: 輸入
日期: 2025-11-15
說明: 使用動態規劃計算每個數字的各位數字和，並統計符合條件的數量
*/

public class DigitSumCounter {
    public static void main(String[] args) throws java.io.IOException {
        java.io.BufferedReader br = new java.io.BufferedReader(new java.io.InputStreamReader(System.in));
        String line = br.readLine();
        if (line == null) return;

        int A;
        try {
            A = Integer.parseInt(line.trim());
        } catch (Exception e) {
            System.out.println(0);
            return;
        }

        // 1..100000 的數字，其位數和的最大值為 45 (即 99999)
        if (A < 1 || A > 45) {
            System.out.println(0);
            return;
        }

        final int MAX_N = 100000;
        int[] digitSum = new int[MAX_N + 1];
        // ds[i] = ds[i/10] + (i % 10)
        for (int i = 1; i <= MAX_N; i++) {
            digitSum[i] = digitSum[i / 10] + (i % 10);
        }

        int count = 0;
        for (int i = 1; i <= MAX_N; i++) {
            if (digitSum[i] == A) count++;
        }

        System.out.println(count);
    }
}