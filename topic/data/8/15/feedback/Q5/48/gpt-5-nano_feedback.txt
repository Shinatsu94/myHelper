87

改進建議：改用更清晰的 3x3 反矩陣公式並加入完整程式註解，以提升可讀性與可維護性。

評分明細與原因：
- 正確性（50/50）：程式能正確計算 3x3 矩陣的反矩陣，並符合要求的輸出格式（非零四位小數，近似為零時輸出 0）。
- 邏輯（28/30）：採用標準的 3x3 反矩陣公式，結構清晰且易於審核；若矩陣行列式為零會輸出提示（雖非題目需求但不影響正確性）。若要更嚴格地評分，可考慮在所有情況下也避免近似等於零但仍輸出四位小數的情形。
- 格式（9/10）：變數命名清晰、縮排良好、符合輸出格式要求；但原作中缺乏程式標頭註解與說明，影響格式分數。
- 備註（0/10）：原作缺少程式檔案標頭註解（檔案名稱、功能、作者、日期）及內部註解，因此此項得分為 0。

修改與優化說明：
- 使用標準 3x3 反矩陣公式直接計算 inv，避免手動堆疊伴隨矩陣的步驟，讓邏輯更清晰且易於維護。
- 保留原有的「若值近似為零就輸出 0」的要求，避免輸出形如 -0.0000。
- 增加程式標頭註解與內嵌註解，提高可讀性與自我註解能力。
- 使用 Locale.US 保證小數點輸出在不同地區設定下都使用純英文句點小數點。

修改後完整程式碼：

// 檔案名稱: MatrixInverse3x3.java
// 功能: 讀入 3x3 矩陣，輸出其反矩陣，非零元素輸出四位小數，值為零時輸出 '0'
// 作者: 教授
// 日期: 2025-11-14
import java.util.Locale;
import java.util.Scanner;

public class MatrixInverse3x3 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        double[][] A = new double[3][3];

        // 輸入 3x3 矩陣
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                if (sc.hasNextDouble()) {
                    A[i][j] = sc.nextDouble();
                }
            }
        }
        sc.close();

        // 計算行列式 det(A)
        double det =
                A[0][0] * (A[1][1] * A[2][2] - A[1][2] * A[2][1])
              - A[0][1] * (A[1][0] * A[2][2] - A[1][2] * A[2][0])
              + A[0][2] * (A[1][0] * A[2][1] - A[1][1] * A[2][0]);

        // 簡化極小的行列式視為無反矩陣
        if (Math.abs(det) < 1e-12) {
            System.out.println("此矩陣沒有反矩陣。");
            return;
        }

        // 直接使用 3x3 的標準反矩陣公式
        double[][] inv = new double[3][3];
        inv[0][0] = (A[1][1] * A[2][2] - A[1][2] * A[2][1]) / det;
        inv[0][1] = (A[0][2] * A[2][1] - A[0][1] * A[2][2]) / det;
        inv[0][2] = (A[0][1] * A[1][2] - A[0][2] * A[1][1]) / det;

        inv[1][0] = (A[1][2] * A[2][0] - A[1][0] * A[2][2]) / det;
        inv[1][1] = (A[0][0] * A[2][2] - A[0][2] * A[2][0]) / det;
        inv[1][2] = (A[0][2] * A[1][0] - A[0][0] * A[1][2]) / det;

        inv[2][0] = (A[1][0] * A[2][1] - A[1][1] * A[2][0]) / det;
        inv[2][1] = (A[0][1] * A[2][0] - A[0][0] * A[2][1]) / det;
        inv[2][2] = (A[0][0] * A[1][1] - A[0][1] * A[1][0]) / det;

        // 輸出反矩陣，顯示規則：
        // 非零輸出四位小數，值接近零的輸出 '0'
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                double v = inv[i][j];
                if (Math.abs(v) < 1e-6) {
                    System.out.print("0");
                } else {
                    System.out.printf(Locale.US, "%.4f", v);
                }
                if (j != 2) System.out.print(" ");
            }
            if (i != 2) System.out.println();
        }
    }
}