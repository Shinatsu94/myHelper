90

改進建議（一句話）：
建議加入完整的檔案標頭註解並改用單向右至左的 O(n) 演算法以提升效率與可讀性。

修改說明與重點：
- 核心改動：將原本的 O(n^2) 兩層迴圈改為 O(n) 的單向遍歷演算法。從右到左掃描，先把最後一個元素設為 -1，然後維護右側「原始值的最大值」maxRight，逐步將 a[i] 設為 maxRight，並用當前 a[i] 的原始值更新 maxRight。
- 原因：原本的雙層迴圈在大數量輸入時效能較差，改用右向追蹤最大值可將時間複雜度降低到 O(n)，且仍能正確處理包含負數的情況。
- 程式結構與可讀性：添加了適當的輸入檢查與輸出，並在檔案開頭加入標頭註解，方便他人理解與維護。

修改後完整程式碼如下（已優化演算法與加入註解與標頭）：
/*
檔案名稱: CSIE_41343121_1031_2.java
功能: 將陣列中每個元素替換為它右側的最大值，最後一個為 -1，並輸出結果。
作者: 徐唯祐
日期: 10/31
*/
import java.util.Scanner;

public class CSIE_41343121_1031_2 {
    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        if (!scn.hasNextInt()) {
            scn.close();
            return;
        }

        int n = scn.nextInt();
        if (n <= 0) {
            scn.close();
            return;
        }

        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = scn.nextInt();
        }

        // O(n) 解法：從右到左追蹤右邊的最大值
        int maxRight = a[n - 1];
        a[n - 1] = -1;
        for (int i = n - 2; i >= 0; i--) {
            int current = a[i];   // 原始值，未被覆寫之前的值
            a[i] = maxRight;      // 將當前位置替換為右側的最大值
            if (current > maxRight) {
                maxRight = current; // 更新右側最大值（使用原始值）
            }
        }

        // 輸出結果，以單一空白區隔，行尾換行
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < n; i++) {
            if (i > 0) sb.append(' ');
            sb.append(a[i]);
        }
        System.out.println(sb.toString());
        scn.close();
    }
}