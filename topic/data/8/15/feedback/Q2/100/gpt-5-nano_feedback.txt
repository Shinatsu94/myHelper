85

該作業評語（一句話簡評）：
原作在邏輯上能正確將每個位置改為右側的最大值且輸出格式符合，但缺少程式標頭註解與命名慣例，且可採用更清晰且效率更佳的實作方式。

改進建議與說明：
- 提升演算法清晰度與效率：改用從右到左單次遍歷，利用 currentMax 保存右側最大值，直接把 arr[i] 設為該值，最後一個設為 -1。這樣時間複雜度為 O(n)，且為就地修改，邏輯更直觀。
- 程式碼風格與命名：改用符合 Java 常用命名（如 Main 類別與變數 n、arr），移除未使用的匯入，保持程式碼整潔。
- 加入程式標頭註解：在檔案頂端加入檔案名稱、功能、作者、日期等註解，方便日後維護。
- 輸出格式維持：仍以空格分隔且結束換行，與題目輸出一致。

修改要點與原因：
- 原始做法使用多層迴圈並在迴圈中修改原陣列，雖能得到正確結果，但可讀性較差且時間複雜度為 O(n^2)。右到左一次遍歷法更直覺、快速且易於維護。
- 將類名改為 Main，符合大多數線上評測的檔名與載入規範，避免編譯錯誤。
- 加入 header 註解，符合作業要求的備註欄位需求。

修改後完整程式碼：
/*
檔案名稱: Main.java
功能說明: 對任意長度整數的一維陣列，將每個元素替換為其右側元素的最大值，最後一個元素為 -1。輸出以空格分隔。
作者: 你的名字
日期: 2025-11-14
*/
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        // 讀取陣列長度
        int n = sc.nextInt();
        int[] arr = new int[n];

        // 讀取陣列元素
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }
        sc.close();

        // 從右到左一次完成：維護右側的最大值
        int currentMax = -1;
        for (int i = n - 1; i >= 0; i--) {
            int original = arr[i];
            arr[i] = currentMax;
            if (original > currentMax) {
                currentMax = original;
            }
        }

        // 輸出結果，空格分隔，末尾換行
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < n; i++) {
            if (i > 0) sb.append(' ');
            sb.append(arr[i]);
        }
        System.out.println(sb.toString());
    }
}