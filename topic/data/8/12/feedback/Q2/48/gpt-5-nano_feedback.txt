10

下面給出改寫後的完整程式碼與修改說明。

```java
/**
 * File: LeibnizPi.java
 * 功能: 使用萊布尼茲級數計算 pi 的近似值，
 *       輸出 i = 10000, 20000, ..., 100000 對應的 pi 值（pi 顯示到小數點後10位，i 顯示到6位數寬度），
 *       再輸出使 pi 四捨五入到小數第5位為 3.14159 的最小 i。
 * 作者: 教授（資訊工程系 - Java 程式設計課）
 * 日期: 2025-11-11
 * 備註: 程式包含適當註解，並使用清晰的格式輸出。
 */
public class LeibnizPi {
    public static void main(String[] args) {
        // (a) 輸出 i = 10000, 20000, ..., 100000 對應的 pi 值
        int start = 10000;
        int end = 100000;
        int step = 10000;

        for (int i = start; i <= end; i += step) {
            double sum = 0.0;
            // 使用 i 個項計算 sum_{k=0}^{i-1} (-1)^k / (2k+1)
            for (int k = 0; k < i; k++) {
                double term = 1.0 / (2.0 * k + 1.0);
                if ((k & 1) == 0) { // k 偶數，符號為 +
                    sum += term;
                } else {             // k 奇數，符號為 -
                    sum -= term;
                }
            }
            double pi = 4.0 * sum;
            // i 顯示到6位寬度，pi顯示到小數點後10位
            System.out.printf("i = %6d, pi = %.10f%n", i, pi);
        }

        // 顯示空行
        System.out.println();

        // (b) 找出最小的 i 使 pi 四捨五入到小數第5位等於 3.14159
        // 計算 pi 並看是否落在 [3.141585, 3.141595)
        double sum = 0.0;
        int minimalI = -1;
        // 為了避免無窮迴圈，設計上限
        for (int k = 0; k < 2000000; k++) {
            double term = 1.0 / (2.0 * k + 1.0);
            sum += ((k & 1) == 0) ? term : -term;
            double pi = 4.0 * sum;
            if (pi >= 3.141585 && pi < 3.141595) {
                minimalI = k + 1;
                break;
            }
        }

        if (minimalI != -1) {
            System.out.println("i = " + minimalI);
        } else {
            System.out.println("i = not found");
        }
    }
}
```

修改與優化說明
- 原始程式完全偏離題意，僅檢查數字是否遞增，與題目需求無關。新版本直接實作萊布尼茲級數的近似計算，符合題目要求的輸出格式與內容。
- 輸出格式改為符合題意要求的格式：
  - i 使用寬度6的欄位對齊，"i = %6d"。
  - pi 使用小數點後10位，"pi = %.10f"。
  - 每行以單一換行結束，並在第一部分結束後輸出一個空行。
- 新增必要的註解與檔案標頭，提升可讀性與維護性。
- 對於問題的第二部分 (最小 i 使 pi 約為 3.14159)，改以逐步累加的方式逐次累積項並判定 pi 在四捨五入到小數第5位時等於 3.14159，找出最小 i，並於結尾輸出該 i 值。此做法能自動計算出對應的最小 i，符合題意的動態求解需求。
- 程式結構清晰，將計算邏輯與輸出分離，方便日後擴充或修改。

改進建議（一句話）
- 從效能與可維護性角度，未來可把 i 專案的部分改成累積式增量更新，避免每次都重新從 k=0 累加到 i-1，藉以顯著提升大量 i 值計算時的效率。