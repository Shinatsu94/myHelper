83

改進建議（一句話）
建議加入程式標頭與內嵌註解、統一命名與容錯處理，並在發現不符合條件時立即結束迴圈以提升可讀性與效能。

評分與理由
- 正確性 50/50
  - 改善前的演算法在絕大多數正整數輸入下正確判斷 Is well-ordered；單位數情況亦正確。若輸入包含負數，原程式無特別處理可能不符合期望的輸出，但問題敘述通常以非負整數為主，因此給予滿分。
- 邏輯 28/30
  - 以從右往左逐位比較的方法是簡單且正確的做法。原程式在發現不遞增時未及時跳出迴圈，若輸入很長的數字可能稍微影響效率。整體邏輯清晰、合理。
- 格式 5/10
  - 原始程式缺乏清晰的變數命名與註解，且未含程式標頭註解，影響可維護性與可讀性。她的風格有潛在的排版不一致問題。
- 備註 0/10
  - 缺少程式標頭註解（檔案名稱、功能、作者、日期等）與內部註解，未符合要求。

修改後程式說明與修改內容
- 新增標頭註解與內嵌註解，提升可維護性與理解度。
- 變數命名改為更具語意的名稱（number、prevDigit、isWellOrdered 等），提升可讀性。
- 新增對負數的處理，採用絕對值進行數字檢查，同時輸出仍以原始輸入顯示，以符合常見使用習慣。
- 使用 while 迴圈與早期退出機制，在遇到不符合條件時立即結束，提升效率。
- 內容維持僅執行一次的要求，輸出格式與題目一致。

修改後完整程式碼
/* 檔案名稱: CSIE_41343121_1017_2.java
 * 功能說明: 判斷輸入的整數各位數是否為嚴格遞增（由左至右）
 * 作者: 教授
 * 日期: 2025-11-15
 * 版本: 1.0
 */

import java.util.Scanner;

public class CSIE_41343121_1017_2 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int original = sc.nextInt();           // 讀取原始輸入，保留作輸出使用
        int number = Math.abs(original);         // 取正數，方便處理位數檢查

        boolean isWellOrdered = true;

        int prevDigit = number % 10;             // 右端位數作為起始比較值
        number /= 10;

        // 從右往左逐位比較，若左位數 >= 右位數，則不符合遞增條件
        while (number > 0) {
            int currentDigit = number % 10;
            if (currentDigit >= prevDigit) {
                isWellOrdered = false;
                break;
            }
            prevDigit = currentDigit;
            number /= 10;
        }

        if (isWellOrdered) {
            System.out.println(original + " is well-ordered number.");
        } else {
            System.out.println(original + " is not well-ordered number.");
        }

        sc.close();
    }
}