82

建議改進說明（一句話）
建議將判定邏輯拆成可讀性更高的函式、統一命名與註解，並增加輸入健全性與檔案命名規範，以提升可維護性與可讀性。

修改說明與評分細項
- 正確性(50%)
  - 現有邏輯在大多數情況下能正確判斷，但為提升穩健性與可讀性，採用更直觀的判斷方式，仍然保持單次輸入結束的需求。原程式對特定邊界情況仍可正確工作，因此維持高分。
- 邏輯(30%)
  - 改用從個位數向左掃描的比較法，透過 prev 初始設定為10，依序比較每位數 d 是否小於前一位，若任一位大於等於前一位即判為非遞增，邏輯更清晰、易於理解與維護。
- 格式(10%)
  - 原始程式的類別名稱為 test，命名不具可讀性；變數命名與縮排可更一致。新版本採用具描述性的類別名稱、清晰的區段劃分與一致縮排。
- 備註(10%)
  - 原程式缺乏檔案標頭註解與說明。新版本加入檔案說明註解、作者與日期欄位，提升可維護性。

修改後完整程式碼
```java
/**
 * File: WellOrderedNumber.java
 * 功能: 判斷輸入的整數各位數字是否嚴格遞增（從左到右）
 * 作者: 您的學生
 * 日期: 2025-11-15
 * 說明: 程式僅執行一次就結束，符合題目需求
 */

public class WellOrderedNumber {
    public static void main(String[] args) {
        java.util.Scanner sc = new java.util.Scanner(System.in);
        if (!sc.hasNextInt()) {
            sc.close();
            return;
        }
        int n = sc.nextInt();
        sc.close();

        if (isWellOrdered(n)) {
            System.out.printf("%d is well-ordered number.\n", n);
        } else {
            System.out.printf("%d is not well-ordered number.\n", n);
        }
    }

    private static boolean isWellOrdered(int n) {
        if (n < 0) return false; // 負數不視為有效位數遞增
        int temp = n;
        int prev = 10; // 任何位數都小於 10
        while (temp > 0) {
            int d = temp % 10;
            temp /= 10;
            if (d >= prev) return false;
            prev = d;
        }
        // 0 或單一位數皆成立
        return true;
    }
}
```

修改重點與原因
- 把判定邏輯分離成獨立方法 isWellOrdered，提升可讀性與重用性。
- 使用從低位數到高位數的遍歷，並以 prev 與當前位數 d 的大小比較，條件更直觀，且不易誤解邏輯。
- 加入程式檔案標頭註解，清楚描述檔案名稱、功能與日期，符合評分標準的備註部分。
- 改用具描述性的類別名稱 WellOrderedNumber，並保留單次輸入需求，提升可維護性與專案整體可讀性。