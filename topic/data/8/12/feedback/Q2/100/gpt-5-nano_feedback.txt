5

評分標準
- 正確性: 0/50
- 邏輯: 0/30
- 格式: 5/10
- 備註: 0/10
總分: 5/100

修改與優化說明
- 本題原始作業與學生程式毫無相關，需改為實作勒貝奇米斯級數計算圓周率的題意內容。
- 改用勒貝奇米斯級數公式 pi = 4 * sum_{k=0}^{i-1} (-1)^k / (2k+1) 進行計算，並輸出指定區間的 i 與 pi 值。
- 輸出格式採用固定寬度以符合題目要求：
  - i 使用寬度為 6 的整數輸出，與前綴 "i = " 相配，產生像題目示例中的空白排版效果。
  - pi 使用小數點後 10 位輸出，保證精度的一致性。
- 為了得到最小的 i 使 pi 穩定落在 3.14159 之五位小數，採用逐步累加的方式，當 pi 四捨五入到五位小數等於 3.14159 時，輸出該 i 值；判定時以將 pi 四捨五入至五位小數後的字串與 "3.14159" 比對，避免浮點誤差導致的判定錯誤。
- 程式不再需外部輸入，直接輸出題意所需的結果，符合題目輸出格式。

修改後完整程式碼
public class LeibnizPi {
    public static void main(String[] args) {
        // Part (a): 依序輸出 i = 10000, 20000, ..., 100000 的 pi 值
        for (int i = 10000; i <= 100000; i += 10000) {
            double sum = 0.0;
            for (int k = 0; k < i; k++) {
                sum += ((k % 2 == 0) ? 1.0 : -1.0) / (2.0 * k + 1.0);
            }
            double pi = sum * 4.0;
            System.out.printf(java.util.Locale.US, "i = %6d, pi = %.10f%n", i, pi);
        }

        // Part (b): 找出最小的 i 使 pi 四捨五入為 3.14159（五位小數）
        int minI = -1;
        double sum = 0.0;
        for (int i = 1; i <= 1000000; i++) {
            int k = i - 1;
            sum += ((k % 2 == 0) ? 1.0 : -1.0) / (2.0 * k + 1.0);
            double pi = sum * 4.0;
            String roundedFive = String.format(java.util.Locale.US, "%.5f", pi);
            if ("3.14159".equals(roundedFive)) {
                minI = i;
                break;
            }
        }
        System.out.println("i = " + minI);
    }
}

修改說明要點
- 將原本與題目無關的輸入/判斷邏輯移除，改為符合題意的 pi 計算與格式輸出。
- 使用字串比對四捨五入至五位小數以確定最小 i，避免浮點數誤差影響判定。

改進建議或反饋（一句話）
- 建議在實作中將 part (a) 的每個 i 的計算視為可累加的增量過程，以避免每次都從頭計算，提高效率；同時可考慮非對稱輸出需求的國際化設定，如 locale 的統一使用以避免小數分隔符差異。