0

評分與評語
- 正確性 (0/50)：原學生提交的程式與題目需求毫無關聯，未能產生正確的輸出。
- 邏輯 (0/30)：原程式缺乏解題邏輯，僅實作數字反轉，與題意無關。
- 格式 (2/10)：程式有基本縮排與可讀性，但變數命名與整體風格不符合題意的規範與需求。
- 備註 (0/10)：無程式標頭註解、缺乏說明與註解。

總分：0

修改與優化說明
1) 新的作業實作思路
- 實作目標改為計算對於公式 pi = 4(1 - 1/3 + 1/5 - 1/7 + ... + (-1)^{i-1}/(2i-1)) 的近似值。
- (a) 輸出 i=10000, 20000, ..., 100000 時的 pi 值，格式符合要求：i 顯示為六位數，pi 顯示到小數點後十位；每行輸出為 "i = 6位寬整數, pi = 10位小數"。
- (b) 找出最小的 i 使 pi 四捨五入到小數點後五位等於 3.14159，並輸出該 i。此處採用逐步累加，並以整數比較避免浮點四捨五入問題。

2) 修改的程式碼及原因
- 原程式嚴重偏離題意，未包含數值計算與格式化輸出，需重新設計成符合題目要求的解法。
- 新程式採用逐步累加的方式計算槓桿和，避免每次都從頭計算，並使用易於檢驗的輸出格式。
- 增加標頭註解，說明檔案名稱、功能、作者、日期，並在程式內容中加入註解，符合作業要求的格式與說明規範。
- 使用字串格式化避免輸出格式不一致，確保 i 的輸出為六位寬、pi 的輸出為小數點後十位。

修改後完整程式碼（Java）如下，請以純文字方式查看：

/*
檔案名稱: PiLeibniz.java
功能: 計算對於 Leibniz 公式近似圓周率
      a) 輸出 i=10000..100000 每次增加 10000 的 pi 值，格式為 i=6位數, pi=10位小數
      b) 找到最小的 i 使 pi 四捨五入到小數點後五位等於 3.14159
作者: 教學評分系統
日期: 2025-11-12
說明: 使用逐步累加方式計算公式 pi = 4 * sum_{k=1}^{i} (-1)^{k-1} / (2k-1)
*/

public class PiLeibniz {
    public static void main(String[] args) {
        // (a) 輸出 i = 10000, 20000, ..., 100000 的 pi 值
        int maxI = 100000;
        double sum = 0.0;
        // 使用從 i = 1 開始的逐步累加，保持 sum 為 sum_{k=1}^{i} (-1)^{k-1} / (2k-1)
        for (int i = 1; i <= maxI; i++) {
            double term = ((i & 1) == 1) ? (1.0 / (2.0 * i - 1.0)) : (-1.0 / (2.0 * i - 1.0));
            sum += term;
            if (i % 10000 == 0) {
                double pi = 4.0 * sum;
                // 輸出格式: i 為六位寬，pi 為小數點後十位
                System.out.println("i = " + String.format("%6d", i) + ", pi = " + String.format("%.10f", pi));
            }
        }

        // (b) 找到最小的 i 使 pi 四捨五入到小數點後五位等於 3.14159
        // 重新從頭開始累加，直到滿足條件
        sum = 0.0;
        int i = 1;
        final long TARGET_ROUNDED = 314159; // 3.14159 * 1e5
        while (true) {
            double term = ((i & 1) == 1) ? (1.0 / (2.0 * i - 1.0)) : (-1.0 / (2.0 * i - 1.0));
            sum += term;
            double pi = 4.0 * sum;
            long rounded = Math.round(pi * 100000.0); // 四捨五入到小數點後五位
            if (rounded == TARGET_ROUNDED) {
                System.out.println("i = " + String.format("%6d", i));
                break;
            }
            i++;
        }
    }
}

說明修改部分的原因
- 對題意進行正確實作：原始程式與題目要求毫無關聯，必須改成正確計算 Leibniz 近似法並符合輸出格式的實作。
- 提升可讀性與可維護性：加入清晰的註解、明確的變數命名與統一輸出格式。
- 提升效能與穩定性：採用逐步累加避免重複計算，使用整數比較避免浮點四捨五入誤差帶來的判定不穩定。
- 符合作業規範的輸出格式：使用字串格式化確保 i 為六位寬、pi 為小數點後十位，且能順利輸出分別對應的兩個小題的結果。

單一句話改進建議
- 在正式提交前，建議再附上測試輸出與說明，並在程式中對每個輸出區塊加入自我檢查以確保與題意嚴格對齊。

如果你願意，我也可以提供一份更嚴謹的單元測試樣例與執行說明，方便學生自行驗證。