75
建議改善點：此作業在處理輸入為 0 的情況會造成無限迴圈，建議改以數字反轉法並處理符號、邊界情況，並加上註解與更清晰的變數命名。

修改與評語說明
- 正確性：原程式在 input 為 0 時會陷入無限迴圈，且僅針對正整數處理，未處理負數與 0 的情形。改用數字反轉法，並特別處理 0、負數情況，能穩定產出正確結果，涵蓋更多邊界情況。得分約 40/50。
- 邏輯：採用通用且直接的數字反轉演算法，邏輯清晰、避免先去除尾零的副作用，且對負數有支援。得分約 28/30。
- 格式：原程式命名較長且缺乏註解，縮排與可讀性可再提升。得分約 7/10。
- 備註：缺乏程式標頭註解與說明。得分 0/10。

優化重點與修改原因
- 處理 0 的情況：避免無限迴圈，輸出 0。
- 使用數字反轉法：直接對數字做反轉，避免先移除尾零的做法，結果等同於反轉後再以數字形式呈現，並天然去除前導零。
- 支援負數：將結果保留符號，提升通用性。
- 增加程式標頭與註解：符合作業規範的註解需求，提高可讀性與維護性。
- 程式碼整潔與命名：使用較清晰的類名與變數說明，提升可讀性。

修改後完整程式碼
/*
File: Main.java
功能: 將使用者輸入的整數的位數反轉，輸出結果。支援正負數，以及輸入為 0 的情況。
作者: 你的老師
日期: 2025-11-15
說明: 使用數字反轉法，遇到 0 時輸出 0；同時保留負號，整體邏輯簡單易懂。
*/

import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        if (!sc.hasNextLong()) {
            sc.close();
            return;
        }

        long n = sc.nextLong();
        sc.close();

        // 特殊邊界：輸入為 0 時，直接輸出 0
        if (n == 0) {
            System.out.println(0);
            return;
        }

        // 記錄符號，對數字部分取絕對值進行反轉
        int sign = (n < 0) ? -1 : 1;
        n = Math.abs(n);

        long rev = 0;
        while (n > 0) {
            rev = rev * 10 + (n % 10);
            n /= 10;
        }

        rev *= sign;
        System.out.println(rev);
    }
}