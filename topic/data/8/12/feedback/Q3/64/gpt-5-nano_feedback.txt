2

作業評分
- 正確性: 0
- 邏輯: 0
- 格式: 2
- 備註: 0
總分: 2

修改後完整程式碼與修改說明
程式檔案名稱（範例）：PiLeibniz.java

修改後完整程式碼（可直接編譯執行）
/*
 檔案名稱: PiLeibniz.java
 功能: 利用勒布尼茲級數計算 pi 的近似值
       (a) 輸出 i=10000,20000,...,100000 時的 pi 值
       (b) 找出最小的 i 使 pi >= 3.14159，並輸出該 i
 作者: 你的姓名
 日期: 2025-11-12
 說明: 不再讀取使用者輸入，直接輸出題目要求的結果格式。
*/
public class PiLeibniz {
    public static void main(String[] args) {
        final int maxI = 100000; // 共計計算到 i = 100000
        double sum = 0.0;

        // (a) 輸出 i=10000, 20000, ..., 100000 的 pi 值
        for (int k = 0; k < maxI; k++) {
            // 第 k 項對應的分母為 (2k+1)，符號依奇偶性決定
            double term = ((k % 2 == 0) ? 1.0 : -1.0) / (2.0 * k + 1.0);
            sum += term;
            int i = k + 1; // 已使用的項數，也就是 nTerms
            if (i % 10000 == 0) {
                double pi = 4.0 * sum;
                System.out.printf("i = %6d, pi = %.10f%n", i, pi);
            }
        }

        // (b) 找出最小的 i 使 pi >= 3.14159
        double partial = sum; // 已計算到 maxI=100000 的部分和
        int i = maxI;
        while (true) {
            i++;
            int k = i - 1; // 新增的項的索引
            double term = ((k % 2 == 0) ? 1.0 : -1.0) / (2.0 * k + 1.0);
            partial += term;
            double pi = 4.0 * partial;
            if (pi >= 3.14159) {
                System.out.println();
                System.out.printf("i = %6d%n", i);
                break;
            }
        }
    }
}

修改原因與重點說明
- 取代原先的無關輸入與字元處理邏輯，改以直接計算勒布尼茲級數的累加和，符合題意的計算需求。
- 使用單一循環逐項累加，輸出需求的 i 值（每 10000 的倍數）時同時輸出 pi，格式化成 i 為寬度 6 的整數、pi 為小數點後 10 位。
- 為方便找出最小 i 使 pi >= 3.14159，保留上一段的累加狀態，繼續逐項加上新的項直到條件成立，並輸出該 i。
- 程式加入註解與標頭說明，便於日後維護與閱讀。

一語話改進建議
- 建議把核心計算與輸出拆成獨立方法（例如計算 pi 的近似、輸出指定 i 的結果、尋找最小 i），以提升可讀性與可重複使用性。