4

以下是依照你的標準對學生作業的評分與改進意見。

評分結果（0-100，分項分數分別為：正確性 50%、邏輯 30%、格式 10%、備註 10%）：
- 正確性：0/50
- 邏輯：0/30
- 格式：4/10
- 備註：0/10
總分：4/100

修改後完整程式碼（已優化以符合題目需求，包含標頭註解、清晰變數命名，以及符合輸出格式的輸出方式）：
/**
 * File: LeibnizPi.java
 * 功能: 計算勒貝金公式 pi 的近似值
 * 需求對應:
 *   (a) 輸出 i = 10000, 20000, ..., 100000 對應的 pi 值，格式為
 *       i =  10000, pi = 3.1414926536
 *   (b) 找出使 pi 四捨五入到小數第5位等於 3.14159 的最小 i，輸出
 *       i = 136121
 * 作者: 由系統提供
 * 日期: 2025-11-12
 * 備註: 不接受外部輸入，直接輸出結果。
 */
public class LeibnizPi {
    public static void main(String[] args) {
        // Part (a): 逐步計算並輸出 i = 10000, 20000, ..., 100000
        for (int i = 10000; i <= 100000; i += 10000) {
            double sum = 0.0;
            for (int k = 0; k < i; k++) {
                // 交替符號，分母為 2k+1
                double term = ((k % 2 == 0) ? 1.0 : -1.0) / (2.0 * k + 1.0);
                sum += term;
            }
            double pi = 4.0 * sum;
            System.out.println("i = " + String.format("%6d", i) + ", pi = " + String.format("%.10f", pi));
        }

        // 輸出空行以分隔兩部分
        System.out.println();

        // Part (b): 找到最小的 i 使 pi 四捨五入至小數第5位等於 3.14159
        double sum2 = 0.0;
        int n = 0; // 以 n 代表使用的項數，對應 i
        while (true) {
            double term = ((n % 2 == 0) ? 1.0 : -1.0) / (2.0 * n + 1.0);
            sum2 += term;
            double pi = 4.0 * sum2;
            n++;
            // 使用四舍五入至第5位的整數比較，若等於 314159，則輸出 i 並結束
            if (Math.round(pi * 1e5) == 314159) {
                System.out.println("i = " + n);
                break;
            }
            // 安全性保護，避免極端情況無限迴圈
            if (n > 2000000) {
                System.out.println("i = " + n);
                break;
            }
        }
    }
}

修改說明與原因：
- 從原始提交的與題目不相關的程式（做數字反轉）改為實作完整的勒貝金公式計算與輸出，符合題目需求與評分標準。
- 將輸出格式固定化，使用 String.format 結合寬度設定，確保 i 以 6 位元寬度對齊、pi 以小數點後 10 位輸出，符合題目提供的輸出樣式。
- 拆分成兩個部分的計算：Part (a) 針對固定的 i 進行逐步加總，Part (b) 以逐項累計的方式找出使 pi 四捨五入到第5位的最小 i，提升可讀性與可維護性。
- 加入標頭註解，包括檔案名稱、功能說明、作者、日期等，滿足備註部分的要求。
- 移除不必要的輸入（Scanner），改以自動輸出，符合題目的「直接輸出結果」需求。

改進建議（一句話）：
- 建議把計算與輸出分解成分別的方法（例如計算 Pi(n) 的函式、找最小 i 的函式），再在主程式呼叫，這樣可提高模組化與測試性。