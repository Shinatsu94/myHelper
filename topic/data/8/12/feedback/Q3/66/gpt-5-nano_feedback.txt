7

修改後完整程式碼：
/*
檔案名稱: LeibnizPi.java
功能: 計算用 Leibozniz(巴塞爾序列)公式近似圓周率
      a) 輸出 i = 10000, 20000, ..., 100000 對應的 pi 值，格式符合題目要求
      b) 找出使 pi 第一次接近 3.14159 的最小 i，輸出格式為單獨一行 "i = <數字>"
作者: 你的教師姓名
日期: 2025-11-11
*/

public class LeibnizPi {
    public static void main(String[] args) {
        // Part (a): 輸出 i 於 10000, 20000, ..., 100000 的 pi 值
        for (int i = 10000; i <= 100000; i += 10000) {
            double sum = 0.0;
            for (int k = 0; k < i; k++) {
                double term = ((k % 2 == 0) ? 1.0 : -1.0) / (2.0 * k + 1.0);
                sum += term;
            }
            double pi = 4.0 * sum;
            System.out.printf("i = %6d, pi = %.10f%n", i, pi);
        }

        // 空一行作為區隔
        System.out.println();

        // Part (b): 找到使 pi 最接近 3.14159 的最小 i
        double target = 3.14159;
        double sum = 0.0;
        int iMin = 0;
        // 設定一個上限，防止無限迴圈；此處以 2,000,000 為上限，通常能找到結果
        for (int k = 0; k < 2000000; k++) {
            sum += ((k % 2 == 0) ? 1.0 : -1.0) / (2.0 * k + 1.0);
            double pi = 4.0 * sum;
            if (Math.abs(pi - target) < 0.00001) {
                iMin = k + 1; // k 為從 0 開始，i 為 k+1
                break;
            }
        }
        System.out.printf("i = %6d%n", iMin);
    }
}

修改說明：
- 重新實作核心演算法：改用 Libniz(Leibniz) 公式 sum_{k=0}^{i-1} (-1)^k/(2k+1)，再乘以 4 以得到 pi。原作未涉及該公式與計算，與題意不符，故以正確的數值近似方法取代。
- 輸出格式調整：使用 System.out.printf 保證 i 以寬度 6 右對齊，pi 設為小數點後 10 位，符合題目輸出要求；第一部分輸出 10 行，之後空一行再輸出第二部分的結果。
- 程式結構與可讀性改善：
  - 增加清晰的註解，分段描述 (a) 與 (b) 的計算邏輯。
  - 採用具意義的變數名稱，並加入程式頭註解（檔案名稱、功能、作者與日期）。
  - 移除不相關的輸入處理，避免混淆題意，直接執行固定範圍的計算。
- 可讀性與維護性提升：統一縮排、適當換行與註解，方便日後維護與再利用。

改進建議（一句話）：
在實作時直接以題目需求的公式與輸出格式為主，並進一步優化為單次沿用的累加計算或前綴和方式以提升效能與可讀性。