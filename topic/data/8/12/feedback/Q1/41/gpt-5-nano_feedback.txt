84
此作業邏輯正確且輸出符合要求；但未提供完整程式標頭註解，且原程式在每個 i 進行重新從頭計算，性能較低，建議改用單一累加方式以提升效率。

改進建議或反饋：
- 建議使用單一累加的方式來計算累加和，以避免重複計算，提升效能，同時補足標頭註解以符合題目要求。

修改與優化說明：
- 優化點1：改為單一累加迴圈，逐次加入下一項的值，避免每次都從 j=1 重新計算，降低時間複雜度，適合大範圍 i 的需求。
- 優化點2：加入完整程式標頭註解與適當的內部註解，提升可讀性與符合備註要求。
- 優化點3：採用更有意義的變數名稱（如 sum、term、pi）以增進可讀性與維護性。
- 優化點4：維持原有輸出格式（i 顯示六位、pi 顯示十位小數），並保留原有的輸出順序與分段空行。

以下為修改後的完整程式碼：

/*
 * File: LeibnizPi.java
 * 功能: 使用萊布尼茲級數近似圓周率 π
 *       a) 輸出 i = 10000, 20000, ..., 100000 時的 pi 值（四倍和的近似）
 *       b) 找出最小的 i 使得 pi 的小數點後五位為 3.14159（用 floor 取五位）
 * 作者: 學生
 * 日期: 2025-11-15
 * 版本: 1.0
 */

public class LeibnizPi {
    public static void main(String[] args) {
        // Part a: 使用單一累加，輸出 i = 10000, 20000, ..., 100000 的 pi 值（精確到小數點後10位）
        double sum = 0.0;
        int maxI = 100000;
        int step = 10000;

        for (int i = 1; i <= maxI; i++) {
            // 第 i 項的符號決定與分母
            double term = (i % 2 == 1) ? 1.0 / (2.0 * i - 1.0) : -1.0 / (2.0 * i - 1.0);
            sum += term;

            if (i % step == 0) {
                double pi = sum * 4.0;
                System.out.println("i = " + String.format("%6d", i) + ", pi = " + String.format("%.10f", pi));
            }
        }

        System.out.println();

        // Part b: 找最小的 i 使得 pi 四舍五入到小數點後五位等於 3.14159
        sum = 0.0;
        int i = 0;
        while (true) {
            i++;
            double term = (i % 2 == 1) ? 1.0 / (2.0 * i - 1.0) : -1.0 / (2.0 * i - 1.0);
            sum += term;
            double pi = sum * 4.0;

            // floor(pi * 100000) / 100000 取得五位小數的截斷值
            if (Math.floor(pi * 100000.0) / 100000.0 == 3.14159) {
                System.out.println("i = " + String.format("%6d", i));
                break;
            }
            // 理論上會收斂到 3.14159 周圍，故應在合理次數內結束
        }
    }
}