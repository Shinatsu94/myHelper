83

以下為依據你的標準所評分與修改說明。

作業評分與評語
- 正確性 (50/50)：程式可正確輸出 a) 10 條 i=10000 到 100000 的 pi 值，與 b) 找到最小的 i 使 pi 落在 [3.14159, 3.1416) 的範圍。數值與格式皆符合題意。
- 邏輯性 (28/30)：採用 Leibniz 公式逐項累加並輸出；對於第 (b) 題，使用同一個累加過程尋找符合範圍的最小 i，邏輯正確且直覺。不過原程式在第二部份採用逐步跳動（每次增加 10）才尋找，雖與答案相符但略顯不直覺且少了說明。優化後可更清楚地表達「累加直到符合條件」的策略。
- 格式 (7/10)：原始程式整體可閱讀，但變數命名簡短（如 T）、缺乏程式標頭註解與內部註解，縮排與一致性尚可再加強。此外，第二段輸出格式使用了非直觀的換行寫法（不影響結果但可改進可讀性）。
- 備註 (0/10)：缺少標頭註解（檔案名稱、功能、作者、日期等）與適當註解，未符合此項要求。

修改後的程式碼與修改理由
- 修改重點
  - 使用單次迴圈累積方式計算前 100000 項的 pi 值，避免對每個 i 重新從頭計算，提升效率。
  - 將第二部分的尋找改為接續前面的累加，逐步增加項數直到 pi 落在指定區間，並輸出最小的 i。
  - 加入標頭註解、適當的內文註解與更清晰的變數命名，提升可讀性與維護性。
  - 保持題目輸出格式，確保 i 與 pi 的輸出格式與對齊符合要求。

修改後完整程式碼（Java）
```java
/*
 * 檔案名稱: LeibnizPi_OPT.java
 * 功能說明: 計算 π = 4(1 - 1/3 + 1/5 - ... ± 1/(2i-1)) 的值
 *          (a) 輸出 i = 10000, 20000, ..., 100000 時對應的 pi 值（精確到小數點後10位）
 *          (b) 找出使 pi 在 [3.14159, 3.1416) 的最小 i，並輸出
 * 作者: 以學生姓名與日期填寫
 * 日期: 2025-11-11
 */
public class LeibnizPi_OPT {
    public static void main(String[] args) {
        // (a) 逐項累加，並在每10000項輸出 pi 的近似值
        double sum = 0.0;
        for (int t = 0; t < 100000; t++) {
            // 第 t 項對應的分母為 (2*t + 1)，符號為 (+) 當 t 偶數，(-) 當 t 奇數
            double term = ((t % 2 == 0) ? 1.0 : -1.0) / (2.0 * t + 1.0);
            sum += term;

            // 當已計算到 (t+1) 項時，若為 10000 的倍數，輸出結果
            if ((t + 1) % 10000 == 0) {
                int i = t + 1;
                double pi = 4.0 * sum;
                System.out.printf("i = %6d, pi = %.10f%n", i, pi);
            }
        }

        // (b) 從 i = 100001 開始，繼續累加直到 pi 落在 [3.14159, 3.1416) 並輸出最小的 i
        int i = 100000;
        while (true) {
            i++;
            int tIndex = i - 1; // 第 i 項對應的 tIndex
            double term = ((tIndex % 2 == 0) ? 1.0 : -1.0) / (2.0 * tIndex + 1.0);
            sum += term;
            double pi = 4.0 * sum;
            if (pi >= 3.14159 && pi < 3.1416) {
                // 使用與題目相同格式輸出，前置換行以與前面輸出分隔
                System.out.printf("%ni = %6d%n", i);
                break;
            }

            // 安全保護，避免在極端情況下無限迴圈
            if (i > 10000000) {
                System.out.println("未找到符合條件的 i。");
                break;
            }
        }
    }
}
```

修改原因說明
- 提升正確性與效率：透過累加的方式逐項加入新項，避免每次都從頭計算，總體運算量顯著降低，對於大 i 的計算更有效率。
- 增強可讀性與維護性：改用更具意義的變數名稱與適當註解，並補上標頭註解，符合作業標準的規範性需求。
- 符合輸出格式：維持題目要求的輸出格式與對齊、輸出位數，確保與樣本輸出一致。

改進建議或反饋（用一句話）
- 使用單次累加的方式替代逐次重算，並把問題 (b) 的尋找與輸出整合到同一個累加過程中，能大幅提升效率與可讀性。