88
改進建議：在(一)部分仍然符合輸出格式與精度要求，但(二)部分的輸出格式與題目樣例不符（僅出現 i 值而非同時輸出 pi），建議改為僅輸出 i，並補上程式標頭註解以提升可維護性與可讀性。

程式優化與修改原因：
- 將程式增補標頭註解（檔案名稱、功能、作者、日期）以符合備註要求，提升自述性與維護性。
- 在輸出部份，對於找出使 pi 逼近 3.14159 的最小 i，改為僅輸出 i（符合題目樣例），避免與 pi 一同輸出造成格式不一致問題。
- 變數命名與邏輯維持清晰，同時使用較為緊湊的寫法（使用條件運算式決定符號）。
- 保留原有逐步輸出每 10000 項的機制，確保(a)部份的輸出與精度符合題意。

修改後完整程式碼
// 檔案名稱: LeibnizPi.java
// 功能說明: 使用 Leibniz 公式計算 pi；輸出每 10000 項的近似值；找到使 pi 接近 3.14159 的最小 i（僅輸出 i）
// 作者: 您的姓名
// 日期: 2025-11-15

public class LeibnizPi {
    public static void main(String[] args) {
        double t = 0.0;      // 部分和 (不乘以 4 的結果)
        double pi = 0.0;     // pi 的近似值
        int i = 1;
        boolean found = false; // 是否已找到使 pi 接近 3.14159 的最小 i

        while (true) {
            // 依 Leibniz 公式新增一項，符號依序正負交替
            double term = (i % 2 != 0) ? (1.0 / (2 * i - 1)) : (-1.0 / (2 * i - 1));
            t += term;
            pi = 4.0 * t;

            // 每 10000 項輸出一次
            if (i % 10000 == 0) {
                System.out.printf("i = %6d, pi = %.10f%n", i, pi);
            }

            // 找到最小的 i 使 pi 與 3.14159 的差小於 0.000005
            if (!found && Math.abs(pi - 3.14159) < 0.000005) {
                System.out.printf("\ni = %d%n", i);
                found = true;
                break; // 找到後結束程式
            }

            i++;
        }
    }
}