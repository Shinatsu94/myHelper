72

改進建議與回饋（一句話）
- 應該避免以嚴格等於的浮點比較找出最小 i，改以四捨五入後的比較或容忍差異，並加上標頭註解與移除未使用的匯入，讓程式結構更清晰、穩健。

程式優化與修改原因說明
- 增加標頭註解，明確說明檔案名稱、功能、作者與日期，符合格式要求的備註規範。
- 移除未使用的 import (java.util.*)，避免不必要的依賴。
- 為第一部份 (a) 仍使用逐次計算的函式 piWithNTerms，保留原有正確性與輸出格式。
- 為第二部份 (b) 改為「逐步累加計算並尋找最小的 n 使 pi 近似值四捨五入至 5 位小數等於 3.14159」，使用 Math.round(pi * 100000) 方式比較，避免直接比較浮點數帶來的誤差問題，並以同樣的條件輸出 i 的值。
- 程式結構調整為單一入口的計算邏輯，提升可讀性與維護性，同時保留輸出格式符合題意（第一段輸出多行、兩段之間空一行；第二段只輸出 i）。

修改後完整程式碼
/*
檔案名稱: PiLeibniz.java
功能: 使用 Leibniz 等級數近似圓周率，輸出一系列 i 與 pi 值(小數點後十位)，
      並找出最小的 i 使 pi 四捨五入至5位小數等於 3.14159。
作者: 教授
日期: 2025-11-15
*/
public class PiLeibniz {
    // 回傳以 n 項項和計算得到的 pi，其中 n 為項數
    public static double piWithNTerms(long n) {
        double sum = 0.0;
        for (long k = 0; k < n; k++) {
            double term = 1.0 / (2 * k + 1);
            if ((k & 1) == 1) term = -term;
            sum += term;
        }
        return 4.0 * sum;
    }

    public static void main(String[] args) {
        // (a) 輸出 i = 10000, 20000, ..., 100000 對應的 pi 值，格式符合題目要求
        for (long n = 10_000; n <= 100_000; n += 10_000) {
            double approx = piWithNTerms(n);
            System.out.printf("i = %6d, pi = %.10f%n", n, approx);
        }

        // 避免與前面的輸出混淆，空一行
        System.out.printf("%n");

        // (b) 找出最小的 i 使 pi 四捨五入至 5 位小數等於 3.14159
        // 使用逐步累加法，避免每次都從頭計算
        double sum = 0.0;
        long iMin = -1;
        for (long k = 0; ; k++) {
            double term = 1.0 / (2 * k + 1);
            if ((k & 1) == 1) term = -term;
            sum += term;
            double piApprox = 4.0 * sum;
            long rounded5 = Math.round(piApprox * 100000L); // 取到小數第5位
            if (rounded5 == 314159L) {
                iMin = k + 1; // 項數 m = k+1
                break;
            }
            // 安全防護：若超過某個極大值仍未找到，避免無窮迴圈
            if (k > 1_000_00000L) {
                break;
            }
        }

        // 依題意僅輸出 i 值
        System.out.println("i = " + iMin);
    }
}