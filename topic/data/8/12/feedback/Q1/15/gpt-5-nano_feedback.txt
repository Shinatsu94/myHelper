61

評分細項
- 正確性：40/50
  - 優點：能輸出前 10 條 i 的 pi 值，且數值與預期接近；使用的公式與迭代次數與題目要求一致。
  - 缺點：原始程式對於 part (b) 的收斂條件邏輯錯誤，可能導致永久迴圈或輸出不符合題意的 i 值。且缺少標頭註解。
- 邏輯：15/30
  - 優點：整體結構清楚，分成兩個需求段落。
  - 缺點：原始的 while 條件寫法不正確，無法穩定終止；變數命名不夠直覺，迴圈內部重新從頭計算也非最優解。
- 格式：6/10
  - 優點：輸出格式接近題意，使用浮點格式化輸出小數點後十位。
  - 缺點：缺乏統一的輸出風格與清晰的程式註解，變數命名不具描述性，缺少程式標頭與註解。
- 備註：0/10
  - 原作缺少檔案標頭註解（檔案名稱、功能、作者、日期等）。

修改後的完整程式碼與修改說明
修改後程式碼（完整可執行版本）：
/*
 * File: LeibnizPi.java
 * 功能: 使用 Leibniz 公式計算 pi，列印 i = 10000, 20000, ..., 100000 的 pi 值（精度到小數點後10位），
 *       以及找出第一個使 pi 的近似落在 3.14159 ~ 3.14160 之間的 i。
 * 作者: 你自己
 * 日期: 2025-11-11
 */
import java.util.Locale;

public class LeibnizPi {
    public static void main(String[] args) {
        Locale.setDefault(Locale.US);

        // (a) 輸出 i = 10000、20000、...、100000 的 pi 值，顯示到小數點後 10 位
        for (int i_terms = 10000; i_terms <= 100000; i_terms += 10000) {
            double piApprox = 0.0;
            for (int t = 0; t < i_terms; t++) {
                int sign = (t % 2 == 0) ? 1 : -1;
                piApprox += (4.0 * sign) / (2 * t + 1);
            }
            System.out.printf("i = %6d, pi = %.10f%n", i_terms, piApprox);
        }

        // (b) 找出最小的 i 使 pi 的近似落在 [3.14159, 3.14160]
        double sum = 0.0;
        int sign = 1;
        int i = 0;
        while (!(sum >= 3.14159 && sum <= 3.14160)) {
            i++;
            sum += 4.0 * sign / (2 * i - 1);
            sign = -sign;
        }
        System.out.printf("i = %6d%n", i);
    }
}

修改原因與重點
- 將 part (b) 的終止條件修正為正式的區間判斷，確保當近似結果落在 [3.14159, 3.14160] 時能正確停止，避免原本的無窮迴圈或不可預期的輸出。
- 統一輸出格式，使用寬度為 6 的整數輸出 i，並固定顯示 pi 至小數點後 10 位，符合題目要求與一致性。
- 加入程式標頭註解與使用 Locale.US，避免國別設定造成小數點格式不同的問題。
- 程式內部解法更清晰：第一部份使用單一內層迴圈逐次累積，易於理解與維護；同時保留原有結果的準確性。
- 提升可讀性：使用自解式命名與適當註解，讓後續維護更方便。

改進建議（一句話）
- 建議在正式提交前，確保分支條件與輸出格式嚴格符合題目規範，並給變數以描述性名稱與完整的註解，提升可讀性與可維護性。