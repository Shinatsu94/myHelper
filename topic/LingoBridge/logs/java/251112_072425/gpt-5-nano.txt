53
- 正確性(50): 25/50
  - 優點：能輸出 a) 部分的 i 與 pi，且使用 Leibniz 級數近似公式計算 pi，結果與題目給出的部分輸出格式相符。
  - 缺點：b) 部分未正確實作；原程式使用逐一比較浮點數是否等於 3.1415999999，且起始點與循環條件不妥，容易造成無法找到正確的最小 i，或需極長時間執行。
- 邏輯(30): 20/30
  - 優點：採用整數、浮點數混合的基本實作邏輯，結構清楚。
  - 缺點：part (b) 的邏輯設計不正確，使用等值比較且從非最小的起始點開始搜尋，且在大範圍搜尋時效率低下。
- 格式(10): 7/10
  - 優點：輸出格式接近要求，使用適當的字元寬度（i 宽度6位、pi 小數10位）。
  - 缺點：原程式有未使用的 import；程式註解雖有中文說明，但缺少標頭註解（檔案名稱、功能、作者、日期等）以符合題目備註要求。
- 備註(10): 1/10
  - 優點：有註解說明功能。
  - 缺點：缺少完整的檔案標頭註解（檔案名稱、作者、日期等），且未清楚描述檔案整體用途與各方法的細節。

以下為修改後的完整程式碼與修改說明。

修改後完整程式碼（Java）
public class PiLeibnizOptimized {
    /*
     * File: PiLeibnizOptimized.java
     * 功能: 使用 Leibniz 級數近似計算 pi，分別輸出
     *       (a) i = 10000, 20000, ..., 100000 對應的 pi 值（到小數第 10 位）
     *       (b) 最小的 i 使 pi 近似值四捨五入到小數點第 5 位等於 3.14159，輸出該 i（6 位數寬）
     * 作者: 你的名字
     * 日期: 2025-11-11
     */

    public static void main(String[] args) {
        // Part (a): 以逐步累加的方式計算 pi，並在 i 為 10000 的倍數時輸出結果
        long maxIForA = 100000;
        double sum = 0.0;
        for (long i = 1; i <= maxIForA; i++) {
            // 第 i 項的符號：當 i 為奇數時為 +，為偶數時為 -
            sum += (( (i - 1) % 2 == 0) ? 1.0 : -1.0) / (2.0 * (i - 1) + 1.0);
            if (i % 10000 == 0) {
                double pi = 4.0 * sum;
                System.out.printf("i = %6d, pi = %.10f%n", i, pi);
            }
        }

        // Part (b): 找到最小的 i，使 pi 四捨五入到 5 位小數等於 3.14159
        // 使用逐步累加，避免浮點數等值比較的問題
        sum = 0.0;
        long targetDigits = 314159; // 3.14159 * 1e5
        long maxIForB = 1_000_000;  // 根據以往結果，136121 在此範圍內
        long foundI = -1;

        for (long i = 1; i <= maxIForB; i++) {
            sum += (( (i - 1) % 2 == 0) ? 1.0 : -1.0) / (2.0 * (i - 1) + 1.0);
            double pi = 4.0 * sum;
            long digits = Math.round(pi * 100000); // 取到 5 位小數四捨五入
            if (digits == targetDigits) {
                foundI = i;
                System.out.printf("i = %6d%n", foundI);
                break;
            }
        }

        // 若未找到也可輸出提示
        if (foundI == -1) {
            System.out.println("i = 未在搜尋範圍內找到符合條件的值");
        }
    }
}

修改之處與改動原因說明
- 重構為單一增量累加法，避免原程式中對 piLeibniz(n) 重複從頭計算的高時間複雜度，提升執行效率。
- 修正 part (b) 的邏輯：
  - 不再使用浮點數相等比較；改以四捨五入到 5 位小數的整數表示比較，避免浮點不確定性。
  - 使用逐步累加的方式計算 sum，避免每次呼叫 piLeibniz(n) 重新計算整個序列，提升表現。
- 增加標頭註解與適當內文註解，提升可讀性與維護性。保留原本的中文註解以說明程式邏輯。
- 輸出格式調整為符合題目要求：i 使用寬度 6，pi 使用 小數點後 10 位；第二部分僅輸出最小 i 的值，與題目範例一致。
- 移除了不必要的 import，避免編譯時警告。

一句話改進建議
- 為了可維護性與效能，建議把「part (a) 與 part (b)」的累加過程整合成同一個迴圈，並在同一次遍歷中同時判斷是否達到 (a) 的輸出條件與 (b) 的最小 i 條件，避免重複計算與多次遍歷。
