85

建議加強程式風格與效能，例如使用更具描述性的變數名稱、加入標頭註解，以及改用從右到左的單次遍歷以降低時間複雜度。

修改說明
- 將演算法改為 O(n) 時間複雜度：利用一個原始值副本 orig，從右到左遍歷，將 a[i] 設為 orig 右側元素的最大值，最後再把 a[n-1] 設為 -1。
- 使用更具描述性的變數名稱（orig、suffixMax、n、a），提高可讀性。
- 增加程式標頭註解與註解，並在結尾關閉 Scanner，提升程式健全性與可維護性。
- 保留原輸入輸出格式，確保在 sample/input 下輸出與題意一致。

修改後完整程式碼
```java
import java.util.Scanner;

/**
 * ArraySuffixMaxReplacement
 * 功能：
 *   1) 讀取一維整數陣列長度與內容
 *   2) 將陣列中每個元素替換為其右側元素中的最大值
 *      (最後一個元素替換為 -1)
 *   3) 輸出替換後的陣列，元素之間以空格分隔
 * 作者：你
 * 日期：2025-11-14
 */
public class ArraySuffixMaxReplacement {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        if (!sc.hasNextInt()) {
            sc.close();
            return;
        }

        int n = sc.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = sc.nextInt();
        }

        // 使用原始值副本以避免覆寫影響右側計算
        int[] orig = a.clone();
        int suffixMax = Integer.MIN_VALUE;
        // 從右到左，a[i] 取 orig[i+1..n-1] 的最大值
        for (int i = n - 1; i >= 0; i--) {
            a[i] = suffixMax;
            if (orig[i] > suffixMax) {
                suffixMax = orig[i];
            }
        }

        // 最後一個元素設定為 -1
        if (n > 0) {
            a[n - 1] = -1;
        }

        // 輸出，避免末尾多餘空格
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < n; i++) {
            if (i > 0) sb.append(' ');
            sb.append(a[i]);
        }
        System.out.print(sb.toString());

        sc.close();
    }
}
```

說明修改部分的效果
- 主要改動在於提升時間效率，將原本的兩層迴圈（O(n^2)）改為單次從右到左的遍歷（O(n)），且透過 orig 複本保留原始值，避免覆寫造成計算錯誤。此外，加入了適當的註解與更清晰的命名，提升程式維護性。
