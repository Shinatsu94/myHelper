分數總計: 2

修改後的完整程式碼（已優化，並符合題目輸出格式與要求）：
/**
 * 檔案名稱: PiLeibniz.java
 * 功能說明: 使用莱布尼茨公式近似 π，輸出 i=10000 到 100000（步階為 10000）時的 pi 值，格式為：
 *          i =  10000, pi = 3.1414926536
 *          每行輸出 i 為 6 位數右對齊，pi 保留小數點後 10 位。
 *          另外計算當 pi 四捨五入到小數點後五位等於 3.14159 時的最小 i，輸出形如: i = 136121
 * 作者: 教師
 * 日期: 2025-11-11
 */
public class PiLeibniz {
    public static void main(String[] args) {
        // 使用增量方式計算：sum 在 i 增加時累加新項目，避免每次重新從 1 開始累加
        int step = 10000;
        double sum = 0.0;
        for (int i = 1; i <= 100000; i++) {
            double sign = (i % 2 == 1) ? 1.0 : -1.0;
            sum += sign / (2.0 * i - 1.0);
            if (i % step == 0) {
                double pi = 4.0 * sum;
                System.out.printf("i = %6d, pi = %.10f%n", i, pi);
            }
        }

        // 找出最小的 i，使 pi 四捨五入到五位小數等於 3.14159
        int minIForFiveDecimals = findMinIForRoundingTarget(3.14159);
        System.out.println("i = " + minIForFiveDecimals);
    }

    // 回傳最小的 i，使 pi 近似值在四捨五入到小數點後五位後等於 3.14159
    private static int findMinIForRoundingTarget(double target) {
        double sum = 0.0;
        int i = 1;
        while (true) {
            double sign = (i % 2 == 1) ? 1.0 : -1.0;
            sum += sign / (2.0 * i - 1.0);
            double pi = 4.0 * sum;
            long rounded = Math.round(pi * 100000.0); // 四捨五入到五位小數
            long targetRounded = Math.round(target * 100000.0); // 3.14159 -> 314159
            if (rounded == targetRounded) {
                return i;
            }
            i++;
            // 安全保護，避免無限迴圈
            if (i > 2000000) break;
        }
        return -1;
    }
}

程式修改之原因與重點說明：
- 對題目需求重新實作：原程式只做數字反轉，與題意完全不符，需改用莱布尼茨級數進行 π 的近似與輸出格式處理。
- 使用增量累加計算 sum：把 i 從 1 累加到 100000，遇到每個 10000 的倍數才輸出對應的 pi 值，提升計算效率與可讀性。
- 輸出格式符合題目要求：
  - i 使用 %6d 右對齊，與先前輸出樣貌一致（i =  10000）。
  - pi 使用 %.10f 保留十位小數。
- 另外額外加入找出最小的 i 使 pi 四捨五入到五位小數等於 3.14159 的功能，並輸出該 i。
- 加入程式標頭註解與適當的註解，提升可閱讀性與維護性。

改進建議（一句話）：
建議在實務中將計算與輸出拆分成模組，並考慮使用基本的單元測試驗證不同 i 值的 pi 結果，以及在關鍵數字處理時引入自動化的格式化檢查，以避免輸出格式偏差。
