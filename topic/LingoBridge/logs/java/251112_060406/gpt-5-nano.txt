第一行總分 (0-100): 12

評分依據與細項
- 正確性 0/50：程式與題目需求無關，未實作題目中 (a) 與 (b) 的計算與輸出。
- 邏輯 0/30：邏輯與題意不符，未展現解題流程與正確演算法。
- 格式 6/10：有基本的程式結構與命名，但與題目需求重點不符合，且註解較少且偏離主題。
- 備註 6/10：有標頭註解與一般說明；與題目內容不符，建議重新對齊題意與註解。

以下為修正後的可行解法與說明

修改後的完整程式碼（符合題意的解題實作）
- 功能說明：
  - 輸出 i = 10000, 11000, ..., 100000 對應的 pi 值，i 為 6 位數寬，pi 為小數點後 10 位。
  - 另外計算 pi = 3.14159 的最小 i 值，並輸出 "i = <minI>"。若需要，會從 100000 開始繼續累加直到找到滿足條件的最小 i。

- 修改原因與要點：
  - 使用逐步累加的並行方式，避免重複計算，提升效率。
  - 輸出格式調整為符合題意（i 使用寬度格式，%)pi 以固定小數位輸出）。
  - 增加註解與標頭資訊，便於維護與閱讀。

完整程式碼如下：
// date:2025/10/17
// program: Leibniz Pi 計算，輸出指定 i 的近似值與最小 i 獲得 pi>=3.14159
// author: 黃榮裕 41343240
// 功能: 使用莱布尼茲級數近似 pi，輸出 i=10000, 20000, ..., 100000 對應的 pi，
//       並找出使 pi >= 3.14159 的最小 i。
// 日期: 2025/10/17
public class LeibnizPiCalculator {
    public static void main(String[] args) {
        final int STEP = 10000;
        final int MAX_I = 100000;

        double sum = 0.0; // 部分和：sum_{k=0}^{i-1} (-1)^k / (2k+1)
        // part (a): 逐步累加到 MAX_I，並每到 STEP 的倍數輸出 pi
        for (int k = 0; k < MAX_I; k++) {
            double term = ((k % 2 == 0) ? 1.0 : -1.0) / (2.0 * k + 1.0);
            sum += term;
            int i = k + 1;
            if (i % STEP == 0) {
                double pi = 4.0 * sum;
                System.out.printf("i = %6d, pi = %.10f%n", i, pi);
            }
        }

        // part (b): 從 MAX_I 開始，繼續累加，找出 pi >= 3.14159 的最小 i
        int minIForPi = -1;
        int k = MAX_I; // 從上一段結束的點繼續累加
        // 避免無止境，設定一個上限；實務上該值會在較大區間找到
        int upperLimit = 2000000;
        while (k < upperLimit) {
            double term = ((k % 2 == 0) ? 1.0 : -1.0) / (2.0 * k + 1.0);
            sum += term;
            int i = k + 1;
            if (minIForPi == -1 && 4.0 * sum >= 3.14159) {
                minIForPi = i;
            }
            k++;
            // 不在此處輸出其他中間值，保持與題意輸出相符
        }

        if (minIForPi != -1) {
            System.out.println("i = " + minIForPi);
        }
    }
}

修改說明摘要
- 重新實作成一份符合題目的 Java 程式，使用累加方式計算萊布尼茲級數近似 pi，逐步輸出 i = 10000, 20000, ..., 100000 對應的 pi，且輸出 pi 的格式符合要求。另加入尋找使 pi >= 3.14159 的最小 i 的邏輯，並在結尾輸出該值。
- 輸出格式優化：使用 System.out.printf 以確保 i 寬度與 pi 小數位數符合題目要求，且第一段輸出中的 i 與 "i = " 的空白寬度能對齊樣本輸出。
- 程式結構與註解：新增標頭註解、清楚的變數名稱與註解，方便後續維護與他人閱讀。

一句話改進建議
- 直接以符合題意的演算法實作、清楚的輸出格式與適當的註解，避免原本與題目無關的內容，並在同一份程式中同時處理多個需求以提升可讀性與維護性。
