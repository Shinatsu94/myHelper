81
- 正確性（50%）：50
  這份作業的輸出與題目要求相符，計算勒布尼茲公式的前 10000、20000、…、100000 項的 pi 值與 pi = 3.14159 的最小 i 均可正確得到，且格式符合要求。
- 邏輯（30%）：25
  原程式邏輯清晰，逐步累加勒布尼茲級數並在指定條件輸出結果；但有未使用變數與可再利用迴圈累加的潛在優化點，邏輯仍屬正確但尚有改進空間。
- 格式（10%）：6
  變數命名合理、輸出格式符合要求；但存在未使用的變數 terms，以及缺少程式標頭與內部註解，降低可讀性與專案風格的一致性。
- 備註（10%）：0
  缺少檔案標頭註解（檔名、功能、作者、日期等）與適當的程式內容註解，因此在備註部分未得分。

修改後完整程式碼與修改原因說明
以下為優化後的完整程式碼，採用單次遍歷進行 pi 的累加與輸出，避免在每個階段重新從頭計算，並補上標頭註解與適當的程式內容註解以符合作業格式與可讀性。

/*
檔案名稱: LeibnizPi.java
功能: 使用勒布尼茲公式近似圓周率
       1) 輸出 i = 10000, 20000, ..., 100000 時的 pi 值，pi 取到小數點後十位，i 取六位寬
       2) 找出使 pi 逼近 3.14159 的最小 i，顯示 i 並符合題目格式
作者: 你的姓名
日期: 2025-11-11
*/
public class LeibnizPi {
    public static void main(String[] args) {
        // Part (a): 逐步累積並於每 10000 項輸出當前 pi 值
        double sum = 0.0;
        int step = 10000;
        int maxI = 100000;
        for (int i = 0; i < maxI; i++) {
            double term = 1.0 / (2 * i + 1);
            sum += (i % 2 == 0) ? term : -term;
            if ((i + 1) % step == 0) {
                int cnt = i + 1;
                System.out.printf("i = %6d, pi = %.10f\n", cnt, 4 * sum);
            }
        }

        // Part (b): 找到第一個使 4*sum 的近似值的整數 i，使 pi*100000 的整數截斷等於 314159
        sum = 0.0;
        long target = 314159L; // 3.14159 * 100000 的截斷值
        for (int i = 0; i <= 10000000; i++) {
            double term = 1.0 / (2 * i + 1);
            sum += (i % 2 == 0) ? term : -term;
            long truncated = (long)(4 * sum * 100000); // floor( pi * 100000 )
            if (truncated == target) {
                System.out.printf("\ni = %6d\n", i + 1);
                break;
            }
        }
    }
}

修改部分說明與原因
- 移除未使用的變數：原程式有未使用的變數 terms，移除以提升整體可讀性與正確性。
- 新增標頭與註解：為符合格式要求，加入檔案名稱、功能說明、作者與日期等，並在程式關鍵段落加上註解，提升可維護性。
- 優化計算方式：將 Part (a) 的 pi 累加改為單次逐步累加並在每 10000 項輸出，避免在每次輸出時重新從頭計算，整體時間複雜度由多次重複累加降低，且不影響結果的正確性。
- 保持輸出格式：輸出字串與題目要求一致，使用 i 的寬度為 6、pi 小數點後十位，並保持單行輸出的格式規範。

改進建議（一句話）
建議進一步將 Part (a) 的整個迴圈與 Part (b) 的判斷整合成單一遍歷，利用同一個累加變數在需要時輸出結果，這樣可以降低複雜度並提升執行效率，同時清理未使用變數與加強註解。
