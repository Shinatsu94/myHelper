7

- 正確性: 0/50
  這份學生提交的程式與題目完全無關，題目要求計算勒貝茲公式近似的圓周率並輸出指定格式，但程式實作的是數字反轉，與題意不符，因此正確性得分為 0。

- 邏輯: 0/30
  程式邏輯與題目需求毫無關聯，未展現任何解題思路或合理解法，因此邏輯分為 0。

- 格式: 7/10
  變數命名較清楚，基本縮排與結構尚可，但因未實作題目要求，難以評估實作格式的完整性；整體可讀性尚可，未包含檔案標頭與完整註解，因此扣分較多，得到 7。

- 備註: 0/10
  未附上程式檔案標頭註解、功能說明、作者與日期等，缺乏適當註解與說明，因此備註分為 0。

程式碼改進與修改說明
- 問題評述
  學生原始程式與題目需求不符，未實作 pi 的近似計算、輸出格式與找尋最小 i 的需求，因此需要提供一份正確且可執行的解法。

- 作法改動
  - 提供一份新的、可解題的 Java 程式，實作勒貝茲級數的 pi 近似計算。
  - 對題目 (a) 的輸出要求逐一輸出 i=10000, 20000, ..., 100000 的 pi 值，pi 以小數點後十位輸出，i 以六位數寬度輸出，且每行格式符合 i = %6d, pi = %.10f。
  - 對題目 (b) 的需求，找出最小的 i，使 pi 的近似值四捨五入到小數點後五位等於 3.14159，並輸出該 i，格式同樣以 i = %6d 顯示。
  - 增加檔案標頭註解與適當的內部註解，提升可讀性與維護性。

- 修改後完整程式碼
以下為修改後的完整程式碼，完整實作題意需求，包含檔案標頭與註解。

/*
 * File: LeibnizPiPrinter.java
 * Description: 計算勒貝茲級數近似 pi，輸出 i=10000,20000,...,100000 對應的 pi 值，並找出最小
 *              i 使近似值四捨五入到小數點後五位等於 3.14159。輸出格式遵循題目要求：
 *              i 與 pi 的輸出分行，i 使用寬度6，pi 使用寬度10小數點。
 * Author: 你的名字
 * Date: 2025-11-11
 */

import java.util.Locale;

public class LeibnizPiPrinter {
    public static void main(String[] args) {
        // 確保小數分隔符為點 (.)
        Locale.setDefault(Locale.US);

        // 題目 (a)：輸出 i = 10000, 20000, ..., 100000 對應的 pi 值
        for (int i = 10000; i <= 100000; i += 10000) {
            double pi = approximatePi(i);
            System.out.printf("i = %6d, pi = %.10f%n", i, pi);
        }

        // 空行分隔
        System.out.println();

        // 題目 (b)：找出最小的 i，使 pi 四捨五入至小數點後5位等於 3.14159
        double targetRounded = 3.14159;
        int foundI = -1;
        for (int i = 1; ; i++) {
            double pi = approximatePi(i);
            double rounded = Math.round(pi * 1e5) / 1e5; // 5 位小數四捨五入
            if (rounded == targetRounded) {
                foundI = i;
                break;
            }
            // 為避免無限迴圈，這裡可設定上限，但題目預期找到值 (約 136121)
            if (i > 2000000) {
                break;
            }
        }
        System.out.printf("i = %6d%n", foundI);
    }

    // 近似 pi 的勒貝茲級數：pi = 4 * sum_{k=0}^{terms-1} (-1)^k / (2k+1)
    private static double approximatePi(int terms) {
        double sum = 0.0;
        for (int k = 0; k < terms; k++) {
            double term = 1.0 / (2 * k + 1);
            if ((k & 1) == 0) {
                sum += term;
            } else {
                sum -= term;
            }
        }
        return 4.0 * sum;
    }
}

- 修改原因說明
  - 讓程式回歸實作題目需求，改為實作勒貝茲級數的 pi 近似與指定輸出格式，並找出最小 i 的需求，提升正確性與實用性。
  - 加入標頭註解與程式內註解，以提升可讀性與維護性，符合教材在備註欄的要求。

一句話改進建議或回饋
- 建議在提交作業前，先與題目逐字對照確認需求是否完整涵蓋，並附上適當的程式標頭與註解，以避免因題外程式造成分數流失。

若有需要，我也可以提供不同輸出格式的版本，或讓程式從使用者輸入控制輸出選項（例如選擇顯示全部區間輸出或僅輸出最終結果）。
