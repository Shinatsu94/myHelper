96

作業評分與修改意見如下：

1) 原始程式評分 (根據你的標準)
- 正確性 (50/50): 100% 正確地計算了 a 部分的多階級和，以及找到最小 i 使 pi 接近 3.14159 的 b 部分。符合題意輸出格式。
- 邏輯 (28/30): 直接逐項重新計算近似值，邏輯清楚、易於理解；但對於 (b) 使用逐步累加的方式比重新從頭計算更高效，原程式雖正確、但效率略低。
- 格式 (9/10): 適當縮排與命名，輸出格式符合要求；部分情況可再提升可讀性與可維護性（例如分離邏輯成函式）。
- 備註 (9/10): 有基本的檔案註解與作者資訊，說明清楚但可再補充更多細節與使用說明。

總分: 96

2) 修改後完整程式碼與修改原因
修改重點：
- 將核心計算分成兩個方法，增進模組化與可測試性。
- (a) 使用單一方法 approximatePi(terms) 計算前 i 項的近似值，避免在主程式中重複寫相同迴圈。
- (b) 使用累加方式逐步逼近 pi，找到首次滿足小數第 5 位等於 3.14159 的最小 i；避免每次從頭計算，提升效率。
- 輸出格式保持原有風格：i 使用寬度 6，pi 使用小數點后 10 位，且在結尾與前一段輸出之間留一個空行。

完整程式碼（已優化）：
public class CSIE_41343240_1017_1 {
    // date: 2025/10/17
    // function: 計算 π 的近似值，並找出最小的項數 i，使 π 的值在小數點第 5 位精確到 3.14159。
    // name&number: 黃榮裕41343240

    public static void main(String[] args) {
        // (a) i = 10000, 20000, ..., 100000
        int[] arr = { 10000, 20000, 30000, 40000, 50000, 60000, 70000, 80000, 90000, 100000 };
        for (int iVal : arr) {
            double pi = approximatePi(iVal);
            System.out.printf("i = %6d, pi = %.10f%n", iVal, pi);
        }

        // (b) 找到最小 i 使 pi ≈ 3.14159 (小數點第5位)
        int minI = findSmallestIForPi3_14159();
        System.out.println();
        System.out.printf("i = %d%n", minI);
    }

    // 計算前 terms 項的 π 的近似值
    private static double approximatePi(int terms) {
        double sum = 0.0;
        for (int k = 1; k <= terms; k++) {
            double term = 1.0 / (2 * k - 1);
            sum += (k % 2 == 1) ? term : -term;
        }
        return 4.0 * sum;
    }

    // 找到最小的 i，使 pi 值的小數第5位為 3.14159
    private static int findSmallestIForPi3_14159() {
        double sum = 0.0;
        int i = 0;
        while (true) {
            i++;
            double term = 1.0 / (2 * i - 1);
            sum += (i % 2 == 1) ? term : -term;
            double piValue = 4.0 * sum;
            // 比對到小數點第5位：如果乘以 100000 後取整等於 314159，表示達到 3.14159
            if ((int) (piValue * 100000) == 314159) {
                return i;
            }
        }
    }
}

3) 改進建議與反饋（一句話）
- 建議以模組化方式分離核心演算法，並使用累加法提升 (b) 部分的效率與可維護性，同時增加單元測試以確保輸出穩定性。
