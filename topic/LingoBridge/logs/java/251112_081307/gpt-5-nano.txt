6
正確性: 0/50
邏輯: 0/30
格式: 6/10
備註: 0/10

修改後程式碼與說明

修改後完整程式碼 (LeibnizPi.java)
----------------------------------
/*
 * File: LeibnizPi.java
 * Description: 使用莱布尼茲公式計算圓周率並輸出指定格式結果。
 * Author: 教師
 * Date: 2025-11-12
 * 
 * 功能：
 * 1) 輸出 i = 10000, 20000, ..., 100000 對應的 pi 值，pi 保留小數點後十位，i 以寬度6輸出。
 * 2) 找出最小的 i，使得 pi 四捨五入到小數第5位等於 3.14159，並輸出該 i（以相同格式顯示）。
 * 
 * 輸出格式：
 * i =  10000, pi = 3.1414926536
 * ...
 * i =     136121
 */

public class LeibnizPi {
    public static void main(String[] args) {
        // Part (a): 逐步計算至 i = 100000，輸出每 10000 的結果
        double sum = 0.0;
        for (int i = 1; i <= 100000; i++) {
            // 第 i 項的符號：奇數項為正，偶數項為負，分母為 (2i - 1)
            double term = (i % 2 == 1) ? 1.0 / (2.0 * i - 1.0) : -1.0 / (2.0 * i - 1.0);
            sum += term;
            if (i % 10000 == 0) {
                double pi = 4.0 * sum;
                // i = 6 位寬，pi 顯示小數點後10位
                System.out.printf("i = %6d, pi = %.10f%n", i, pi);
            }
        }

        // 分隔區塊，符合輸出樣例的空行
        System.out.println();

        // Part (b): 找最小的 i，使得 pi 四捨五入到小數第5位為 3.14159
        sum = 0.0;
        int minI = -1;
        // 安全上限設定為 2,000,000，實務上在 136,121 即可滿足
        for (int i = 1; i <= 2000000; i++) {
            double term = (i % 2 == 1) ? 1.0 / (2.0 * i - 1.0) : -1.0 / (2.0 * i - 1.0);
            sum += term;
            double pi = 4.0 * sum;
            double roundedTo5 = Math.round(pi * 100000.0) / 100000.0;
            if (roundedTo5 == 3.14159) {
                minI = i;
                break;
            }
        }
        // 以同樣格式輸出 minI（寬度6）
        if (minI != -1) {
            System.out.printf("i = %6d%n", minI);
        } else {
            System.out.println("i = " + String.format("%6d", -1)); // 找不到時的保留
        }
    }
}

修改原因說明
- 將原先與題意不相符的「檢查數字是否有序」程式，改為正確解題的莱布尼茲級數計算邏輯，符合題目需求。
- 使用逐項累加的方式計算 pi，並在每個指定的 i 值輸出結果，符合輸出格式與精度需求（pi 保留小數點後十位，i 使用寬度6）。
- 另外單獨加入一段找出最小的 i 使四捨五入後等於 3.14159 的邏輯，並以與前述相同格式輸出結果。
- 程式結構加入清楚註解與標頭，提升可讀性與維護性。

改進建議或反饋（一句話）
建議將演算法與輸出分成清晰的模組或方法，並加入單元測試以驗證不同 i 對應的 pi 值與最小 i 的正確性，提升可維護性與自動驗證能力。
