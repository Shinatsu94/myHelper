80

改進建議：整體功能正確且輸出格式符合需求，但缺少完整的檔案註解與容錯處理，建議加入標頭註解、統一風格與浮點容错，以提升可讀性與穩健性。

修改說明與修改後程式碼

修改重點與原因:
- 增加檔案頭註解，包含檔案名稱、功能、作者與日期，符合作業備註的要求。
- 使用 try-with-resources 管理 Scanner，避免顯式 close 的遺漏或資源洩漏風險。
- 引入小於 EPS 的浮點容錯機制，避免浮點比較造成的誤判，同時保留原本對於接近零值輸出 0 的需求。
- 將輸出為零的判斷與格式化集中在一個輔助方法 printValue，提升重複使用與可讀性。
- 對不可逆矩陣在浮點情況下也能穩健判斷，避免直接用 det == 0 的比對造成誤判（改以絕對值比較）。

修改後完整程式碼如下：

import java.util.Scanner;
import java.text.DecimalFormat;

/**
 * File: CSIE_51015114_1031_5.java
 * Description: 讀入 3x3 矩陣，輸出其反矩陣。若元素為零，輸出 0；其餘數字輸出至小數點後四位。
 *              若矩陣不可逆，輸出提示訊息「矩陣不可逆」。
 * Author: 教師
 * Date: 2025-11-14
 */
public class CSIE_51015114_1031_5 {
    private static final double EPS = 1e-8;

    public static void main(String[] args) {
        try (Scanner sc = new Scanner(System.in)) {
            double[][] A = new double[3][3];

            // 讀入 3x3 矩陣
            for (int i = 0; i < 3; i++) {
                for (int j = 0; j < 3; j++) {
                    if (!sc.hasNextDouble()) {
                        return;
                    }
                    A[i][j] = sc.nextDouble();
                }
            }

            double det = determinant(A);
            if (Math.abs(det) < EPS) {
                System.out.println("矩陣不可逆");
                return;
            }

            double[][] inv = inverse(A, det);

            // 格式化輸出
            DecimalFormat df = new DecimalFormat("0.0000");

            for (int i = 0; i < 3; i++) {
                for (int j = 0; j < 3; j++) {
                    printValue(inv[i][j], df);
                    if (j < 2) {
                        System.out.print(" ");
                    }
                }
                System.out.println();
            }
        }
    }

    // 計算 3x3 矩陣的行列式
    public static double determinant(double[][] m) {
        return m[0][0]*(m[1][1]*m[2][2]-m[1][2]*m[2][1])
             - m[0][1]*(m[1][0]*m[2][2]-m[1][2]*m[2][0])
             + m[0][2]*(m[1][0]*m[2][1]-m[1][1]*m[2][0]);
    }

    // 計算反矩陣
    public static double[][] inverse(double[][] m, double det) {
        double[][] inv = new double[3][3];

        inv[0][0] =  (m[1][1]*m[2][2] - m[1][2]*m[2][1]) / det;
        inv[0][1] = -(m[0][1]*m[2][2] - m[0][2]*m[2][1]) / det;
        inv[0][2] =  (m[0][1]*m[1][2] - m[0][2]*m[1][1]) / det;

        inv[1][0] = -(m[1][0]*m[2][2] - m[1][2]*m[2][0]) / det;
        inv[1][1] =  (m[0][0]*m[2][2] - m[0][2]*m[2][0]) / det;
        inv[1][2] = -(m[0][0]*m[1][2] - m[0][2]*m[1][0]) / det;

        inv[2][0] =  (m[1][0]*m[2][1] - m[1][1]*m[2][0]) / det;
        inv[2][1] = -(m[0][0]*m[2][1] - m[0][1]*m[2][0]) / det;
        inv[2][2] =  (m[0][0]*m[1][1] - m[0][1]*m[1][0]) / det;

        return inv;
    }

    // 將數值輸出成指定格式，值為近似零時輸出 0
    private static void printValue(double v, DecimalFormat df) {
        if (Math.abs(v) < EPS) {
            System.out.print("0");
        } else {
            System.out.print(df.format(v));
        }
    }
}

說明：修改後的程式在可讀性與魯棒性方面有所提升，且保留原有的輸出格式與零值顯示的需求。若未來要在非整數輸入或更多矩陣維度上工作，建議再抽象成可重用的矩陣運算工具類別。
