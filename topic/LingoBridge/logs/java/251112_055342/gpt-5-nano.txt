8

評分明細
- 正確性 (50%): 0/50
  - 原學生程式與題目要求之計算無關，未實作 pi 的近似與輸出格式，屬於嚴重偏離作業需求。
- 邏輯 (30%): 0/30
  - 程式邏輯與題目無關，且實作的是一個判斷位數遞增的函式與主流程，並未呈現計算 pi 的邏輯或流程。
- 格式 (10%): 8/10
  - 程式碼整體可讀性尚可，具合理縮排與命名，但與題目需求不符，且缺乏適當的註解與標頭說明，影響可維護性。
- 備註 (10%): 0/10
  - 未提供檔案名稱、功能、作者、日期等程式標頭註解與適當說明。

修改與改進說明
- 提供一份符合題目需求的完整實作，計算 pi 的連續級數近似值，並依題目給定的輸出格式輸出結果。
- 將原有的與題意無關的 WellOrderedNumber 程式改寫為計算 Leviniz 级数近似 pi 的程式，且加入適當的檔案標頭與註解說明。
- 優化重複計算：採用累積和的方式逐步計算直到 100000 項，避免每次都重新從頭計算，提高執行效率。
- 輸出格式調整：
  - i 顯示為寬度 6 的欄位（"%6d"），符合「i 顯示到6位數」的要求。
  - pi 顯示為小數點後 10 位（"%.10f"）。
  - 每行輸出一個換行，並以單個空白分隔輸出內容，符合題目指定的格式。

修改後完整程式碼
// 檔案名稱: PiLeibniz.java
// 功能: 計算 pi 的近似值，輸出 i 為 10000,20000,...,100000 對應的 pi 值，格式符合題目要求。
// 作者: [你的名字]
// 日期: [日期]

public class PiLeibniz {
    public static void main(String[] args) {
        final int maxI = 100000; // 最大的 i 值
        double sum = 0.0;        // 逐項累積的和，代表 sum_{k=0}^{i-1} (-1)^k / (2k+1)
        StringBuilder output = new StringBuilder();

        // 以單一迴圈累積到 maxI，對於每到達 10000 的倍數就輸出結果
        for (int k = 0; k < maxI; k++) {
            sum += ( (k % 2 == 0) ? 1.0 : -1.0 ) / (2.0 * k + 1.0);
            int i = k + 1;
            if (i % 10000 == 0) {
                double pi = 4.0 * sum;
                output.append(String.format("i = %6d, pi = %.10f%n", i, pi));
            }
        }

        System.out.print(output.toString());
    }
}

說明修改部分的原因
- 重新聚焦題目需求：原程式與題目計算需求完全無關，需改為實作 pi 的近似計算與格式化輸出。
- 提高效能：改用一次性累積（而非每次重新從頭計算）的做法，降低時間複雜度。
- 輸出格式符合要求：使用寬度對齊輸出 i、以及 pi 的小數位數格式化，確保與題目給定的輸出範例相符。
- 增加可維護性與可讀性：加入檔案標頭註解，並清楚註解核心變數與流程。

改進建議與反饋（一句話）
- 建議將實作分段封裝成方法（如 computePiForNTerms、formatOutput），並在主程式中呼叫，提升可讀性與測試性，同時再加入更多註解以利後續維護。

補充說明
- 原題要求的輸出樣式與欄位寬度在新程式中透過 String.format 進行嚴格控制，且不需要外部輸入，程式會自動輸出 i = 10000, 20000, …, 100000 對應的 pi 值，且 pi 後十位小數的精度符合題意。若要動態輸入或改變輸出範圍，可再將最大項數與步階改為可設定的參數。
