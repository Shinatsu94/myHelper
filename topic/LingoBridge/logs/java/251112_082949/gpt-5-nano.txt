3

以下是評分與修改說明：

- 正確性: 0/50
  - 學生的程式未解題，僅實作了數字翻轉與去除尾零的功能，與題目需求的李賽尼級數計算與指定輸出格式完全不符。

- 邏輯: 0/30
  - 程式邏輯與作業需求相去甚遠，未採用正確的演算法或流程來計算 pi、輸出指定格式及最後的 i 值。

- 格式: 3/10
  - 程式風格尚可閱讀，但命名不具描述性，缺乏註解與檔案標頭，且未符合題目輸出格式的要求。

- 備註: 0/10
  - 缺乏程式標頭註解與說明。

總分：3

修改後完整程式碼（僅為示範性修正，已符合題意要求的輸出格式與演算法）：
/*
 * File: LeibnizPi.java
 * 功能: 使用李賽尼級數 4 * sum_{n=0}^{i-1} (-1)^n / (2n+1) 逐步近似 π。
 *       輸出 i = 10000, 20000, ..., 100000 對應的 π（小數點後10位），
 *       並找出使 π >= 3.14159 的最小 i，單行輸出形式與題目要求一致。
 * 作者: 你的姓名
 * 日期: 2025-11-12
 */
public class LeibnizPi {
    public static void main(String[] args) {
        long iMax = 100000; // 要輸出到的最大 i（每10000輸出一次）
        double sum = 0.0;   // 目前的級數和，注意是未乘以4的部分

        // 逐步累加李賽尼級數，並在每10000次輸出 pi 值
        for (long i = 1; i <= iMax; i++) {
            // 第 i 項的值：(-1)^(i-1) / (2i - 1)
            double term = ((i % 2 == 1) ? 1.0 : -1.0) / (2.0 * i - 1.0);
            sum += term;
            if (i % 10000 == 0) {
                double pi = 4.0 * sum;
                // i 以宽度6对齐，Pi保留小数点后10位
                System.out.printf("i = %6d, pi = %.10f%n", i, pi);
            }
        }

        // 尋找使 pi >= 3.14159 的最小 i，從 iMax+1 繼續累加
        long minimalI = -1;
        for (long i = iMax + 1; ; i++) {
            double term = ((i % 2 == 1) ? 1.0 : -1.0) / (2.0 * i - 1.0);
            sum += term;
            double pi = 4.0 * sum;
            if (pi >= 3.14159) {
                minimalI = i;
                break;
            }
            // 為避免極端情況，設定安全上限
            if (i > 2000000) {
                break;
            }
        }

        // 輸出最後的最小 i，格式與前述一致（i = 136121 的樣式）
        System.out.println("i = " + String.format("%6d", minimalI));
    }
}

修改說明與原因：
- 由原先讀入整數並反轉輸出改為實作李賽尼級數的實際計算。因為題目需計算 pi 的近似值，直接輸出顯示。
- 使用逐步累加的方式，讓每增加一項就能直接得到對應的 pi 值，並在每 10000 項輸出一次，符合題目給定的輸出時序與格式。
- 輸出格式調整為：
  - i 使用寬度6的右對齊，pi 使用小數點后10位，透過 System.out.printf 实現，符合題目要求的格式。
- 增加對第(b)題的處理，從 i = 100001 開始繼續累加，找到使 pi >= 3.14159 的最小 i，並以單獨一行輸出，與前面的格式保持一致。
- 加上檔案標頭註解及註解，提升可維護性與可讀性。

改進建議或反饋（一句話）：
- 建議未來將演算法與輸出格式分離為方法，並在主程式中清楚呼叫，以提升可讀性與可重用性，同時加入註解說明每段邏輯的目的。
