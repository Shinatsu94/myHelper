總分 (0-100)
64

改進建議一句話
建議在批改中加入完整的程式註解與標頭，並修正 (b) 部分的比較邏輯與變數命名，同時採用增量計算以提升可讀性與效率。

評分細目與說明
- 正確性 (50%)
  - (a) 正確，能輸出 i=10000 到 100000（步階為 10000）的 pi 值，格式符合要求。
  - (b) 原程式中的比較邏輯有誤：使用了 4*pi 的結果與 3.14159 的比較，導致找不到預期的 i；因此此部分不正確。整體正確性較低，因此給分較低。
  總計：40/50
- 邏輯 (30%)
  - (a) 使用逐步累加的思路可讀性高且合理；原程式每次都從頭計算，效率較低但正確。
  - (b) 想法是正確的，但原先的實作在比較時加入了不當的 4 倍因子，造成邏輯失效。
  總計：18/30
- 格式 (10%)
  - 變數命名基本有意義；輸出格式與對齊符合題目要求（i 以 %6d 輸出，pi 以 %.10f）。
  - 程式中有未使用的變數，如 terms；且缺少程式標頭與註解。
  總計：6/10
- 備註 (10%)
  - 缺少程式檔頭註解（檔案名稱、功能、作者、日期等），也缺乏逐步說明與內部註解。
  總計：0/10

修改與優化說明
- 新增程式標頭註解，說明檔案名稱、功能、作者、日期等，提升可維護性。
- 對於 (a) 採用增量法計算：使用一個迴圈逐步把新項加入累積的和，避免每次都從 0 開始重新計算，提升效率並提升程式可讀性。
- 對於 (b) 修正判斷邏輯：改以 pi 的近似值乘以 1e5 後去取整數，與目標 314159 比較；不再乘以 4，使得比較對應到「3.14159 的五位小數」的取整結果，更符合題意。
- 移除未使用變數，並保持變數命名清晰，增加註解以說明每段邏輯。
- 輸出格式保持原有樣式，仍使用 i = %6d 與 pi = %.10f 的格式，維持與題目樣例的對齊。

修改後完整程式碼
```java
/**
 * File: LeibnizPi.java
 * 功能: 使用 Leopold 枚舉(Leibniz)公式近似圓周率:
 *       pi = 4(1 - 1/3 + 1/5 - 1/7 + ... + (-1)^(i-1) / (2i-1))
 *       (a) 輸出 i = 10000, 20000, ..., 100000 的 pi 值，格式為 pi 小數點後 10 位。
 *       (b) 找出使 pi ≈ 3.14159 時的最小 i（以 i 為項數，且 result 取整到小數點後 5 位）。
 * 作者: 參考範例修正
 * 日期: 2025-11-15
 */
public class LeibnizPi {
    public static void main(String[] args) {
        // (a) 使用增量法計算，輸出 i = 10000, 20000, ..., 100000
        double sum = 0.0;
        int lastCnt = 0;
        int step = 10000;
        int maxCnt = 100000;
        for (int cnt = step; cnt <= maxCnt; cnt += step) {
            for (int k = lastCnt; k < cnt; k++) {
                double term = 1.0 / (2 * k + 1);
                sum += (k % 2 == 0) ? term : -term;
            }
            lastCnt = cnt;
            double piApprox = 4.0 * sum;
            System.out.printf("i = %6d, pi = %.10f%n", cnt, piApprox);
        }

        // (b) 找最小的 i 使 pi ≈ 3.14159
        // 以 pi 的近似值乘 1e5 後取整，與 3.14159*1e5 做比較
        double sumB = 0.0;
        long target = 314159L; // 3.14159 * 1e5
        int foundIndex = -1;
        for (int i = 0; i <= 20000000; i++) {
            double term = 1.0 / (2 * i + 1);
            sumB += (i % 2 == 0) ? term : -term;
            long truncated = (long)(sumB * 100000);
            if (truncated == target) {
                foundIndex = i + 1; // 依題意 i 從 1 開始計數
                break;
            }
        }

        System.out.println();
        if (foundIndex != -1) {
            System.out.printf("i = %6d%n", foundIndex);
        } else {
            System.out.println("i not found within bound");
        }
    }
}
```

補充說明
- 若要進一步提升可讀性與維護性，可以把計算單位拆成方法，例如一個方法負責計算到某個 cnt 的近似值、一個方法負責找尋滿足條件的 i 等等。
- 若需要嚴格自動化測試，建議 separate 參數化測試，確認 (a) 的輸出與題目給定的樣例逐條比對、(b) 的最小 i 是否符合預期。
