2

修改後完整程式碼如下（已符合題目要求的輸出格式與功能）：

/*
 * 檔名：PiLeibniz.java
 * 功能：使用 Leibniz 公式計算 pi 的近似值，輸出 i 為 10000, 20000, ..., 100000 時的 pi，格式為
 *       i 6位數對齊與 pi 小數點後 10 位；另外找出使 pi 四捨五入至小數第5位為 3.14159 的最小 i。
 * 作者：改寫以符合作業題意
 * 日期：2025-11-11
 * 說明：透過累積和避免重複計算，並逐步輸出指定 i 的近似值。
 */
public class PiLeibniz {
    public static void main(String[] args) {
        final int STEP = 10000;
        final int MAX_I = 100000;

        // 使用累積和方式，逐步計算 pi 的近似，僅在 i 為 STEP 的倍數時輸出
        double sum = 0.0;
        for (int i = 1; i <= MAX_I; i++) {
            double term = ((i - 1) % 2 == 0) ? 1.0 / (2.0 * i - 1.0) : -1.0 / (2.0 * i - 1.0);
            sum += term;
            if (i % STEP == 0) {
                double pi = 4.0 * sum;
                // i 為 6 位數寬，pi 為小數點後 10 位
                System.out.printf("i = %6d, pi = %.10f%n", i, pi);
            }
        }

        // 找出最小的 i，使 pi 四捨五入至小數第 5 位等於 3.14159
        sum = 0.0;
        int minIForPi = -1;
        for (int i = 1; i <= 2000000; i++) {
            double term = ((i - 1) % 2 == 0) ? 1.0 / (2.0 * i - 1.0) : -1.0 / (2.0 * i - 1.0);
            sum += term;
            double pi = 4.0 * sum;
            if (Math.round(pi * 100000.0) == 314159) { // 3.14159 的整數表示
                minIForPi = i;
                break;
            }
        }

        // 輸出最小 i（6 位寬格式，與前述輸出風格一致）
        System.out.printf("i = %6d%n", minIForPi);
    }
}

修改部分的原因說明：
- 取代原作業樣本的與題意無關的輸入判斷程式，直接實作 pi 計算與輸出，符合題目需求。
- 使用累積和方式逐步增加項數，避免每次都從頭計算，提升執行效率。
- 輸出格式以格式化字串 printf 來控制 i 的寬度與 pi 的小數位數，確保與題目要求一致。
- 新增第一部分輸出與第二部分的結合：在同一程式中同時輸出 10000~100000 的 pi 近似值，並找出最小 i 使 pi 接近 3.14159，滿足 (a) 與 (b) 兩部分需求。

單句改進建議：
- 建議在正式批改前先確認題目對輸出格式的細節（如空白與換行位置）與極端情況的處理，並搭配單元測試以驗證 pi 的近似精度與四捨五入邏輯。
