3

評分與回饋
- 正確性 (0/50)：提交的程式與題目要求毫無關聯，原程式僅判斷數字的數位排列，未計算或輸出圓周率近似值，也沒有處理題目中的輸出格式與最後的最小 i 值要求。
- 邏輯 (0/30)：邏輯與解題方向嚴重偏離；無法以合理、簡單的邏輯解決所給的公式與輸出需求。
- 格式 (3/10)：程式有基本的排版與縮排，但命名不具可讀性且缺乏說明與註解，且檔案名稱與內容未符合題意。整體結構尚可閱讀性改善空間大。
- 備註 (0/10)：缺乏程式檔頭註解（檔案名稱、功能、作者、日期等說明），無內部註解來說明邏輯與演算法。
- 總分: 3/100

修改說明與原因
- 需求對應：改成自成一個獨立的小程序，輸出題目要求的 i 值序列與 pi 值，並另外找出使 pi >= 3.14159 的最小 i。原程式與題意不符，故全面改寫。
- 演算法改進：使用 Leibniz 公式 pi = 4 * sum_{n=0}^{i-1} (-1)^n / (2n+1)，逐步累計求出 i=10000, 20000, ..., 100000 的 pi 值，避免重複計算，並在結束後繼續累積尋找最小的 i 使 pi >= 3.14159。
- 輸出格式：依題意以 System.out.printf 輸出，第一部分 i 使用寬度 6 的對齊格式（i = %6d, pi = %.10f），確保 i 顯示到六位數，pi 保留小數點後十位；之後再輸出一行空白與結果 i。
- 程式結構與註解：加入檔案頭註解與必要的內部註解，使用具有描述性的類名，避免不相關的輸入需求。
- 檔案命名與可維護性：提供清晰的檔案內容與註解，便於日後維護與評分。

修改後完整程式碼
// LeibnizPiPrinter.java
// 功能: 輸出 pi 的近似值 (按題目給定的 i 序列) 以及最小 i 使 pi >= 3.14159
// 作者: [您的姓名]
// 日期: [日期]
public class LeibnizPiPrinter {
    public static void main(String[] args) {
        // 目標 i 序列
        int[] targets = {10000, 20000, 30000, 40000, 50000,
                         60000, 70000, 80000, 90000, 100000};

        double sum = 0.0;
        // 最大 i 的項數
        int maxI = 100000;

        // 逐項計算並在每個 target 出現時輸出 pi 值
        int tIndex = 0;
        for (int n = 0; n < maxI; n++) {
            double term = ((n % 2 == 0) ? 1.0 : -1.0) / (2.0 * n + 1.0);
            sum += term;

            if (tIndex < targets.length && (n + 1) == targets[tIndex]) {
                double pi = 4.0 * sum;
                System.out.printf("i = %6d, pi = %.10f%n", targets[tIndex], pi);
                tIndex++;
            }
        }

        // 找出使 pi >= 3.14159 的最小 i
        // 目前 sum 已累積至 i = maxI (= 100000)
        int iFound = -1;
        int n = maxI; // 從 100000 的下一項繼續往後找
        while (true) {
            double term = ((n % 2 == 0) ? 1.0 : -1.0) / (2.0 * n + 1.0);
            sum += term;
            double pi = 4.0 * sum;
            if (pi >= 3.14159) {
                iFound = n + 1; // i 為項數，對應 n 從 0 開始
                break;
            }
            n++;
        }

        System.out.println();
        System.out.println("i = " + iFound);
    }
}

修改原因說明
- 以逐步累計的方式計算近似 pi，避免每次都重新整段求和，提升效率並保留簡單易懂的邏輯。
- 嚴格按照題目格式輸出，確保 i 的列寬為 6 位，pi 為小數點後 10 位。
- 加入清楚的註解和標頭，提升可讀性與可維護性。

改進建議與反饋（一句話）
- 建議在提交作業時，直接針對題意編寫自說明清楚的註解與完整輸出格式，並附上測試案例與預期輸出，以避免評分時因不清楚的要求而造成分數損失。
