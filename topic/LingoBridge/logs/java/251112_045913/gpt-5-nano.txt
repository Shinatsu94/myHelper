84

修改後完整程式碼：
public class CSIE_41343111_1017_1 {
    /*
     * 檔案名稱: CSIE_41343111_1017_1.java
     * 功能說明: 根據 Leibniz 公式計算 pi
     *          (a) 輸出 i = 10000, 20000, ..., 100000 對應的 pi 值，pi 保留小數點後 10 位
     *          (b) 找出最小的 i 使 pi 逼近 3.14159，且落在區間 [3.14159, 3.1416)
     * 作者: 資工系教授
     * 日期: 2025-11-11
     * 註解說明: 使用單一累加迴圈逐步累加項，並在適當條件輸出，提升可讀性與效率
     */
    public static void main(String[] args) {
        final int MAX_TERMS = 100000;       // 部分 (a) 要計算到的項數
        final double TARGET_LOW = 3.14159;  // 部分 (b) 下界
        final double TARGET_HIGH = 3.1416;   // 部分 (b) 上界

        double sum = 0.0; // Leibniz 系列前 i 項之和，實際 pi 會乘以 4

        // 部分 (a): 輸出 i = 10000, 20000, ..., 100000 對應的 pi 值
        for (int i = 1; i <= MAX_TERMS; i++) {
            // 第 i 項的符號：i=1 為 +，之後交替符號
            // 第 i 項的分母為 2*i - 1
            double term = (((i - 1) & 1) == 0) ? 1.0 / (2.0 * i - 1.0) : -1.0 / (2.0 * i - 1.0);
            sum += term;
            if (i % 10000 == 0) {
                double pi = sum * 4.0;
                System.out.printf("i = %6d, pi = %.10f%n", i, pi);
            }
        }

        // 部分 (b): 從 MAX_TERMS+1 開始繼續累加，找到第一個落在 [3.14159, 3.1416) 的 i
        int i = MAX_TERMS;
        while (true) {
            i++;
            double term = (((i - 1) & 1) == 0) ? 1.0 / (2.0 * i - 1.0) : -1.0 / (2.0 * i - 1.0);
            sum += term;
            double pi = sum * 4.0;
            if (pi >= TARGET_LOW && pi < TARGET_HIGH) {
                System.out.printf("i = %6d%n", i);
                break;
            }
            // 防呆機制，避免極端狀況造成無限迴圈
            if (i > 1000000) {
                System.out.printf("i = %6d%n", i);
                break;
            }
        }
    }
}

修改說明：
- 將原本的多重巢狀迴圈改為單一累加過程，使用逐項累加的方式計算 Leibniz 公式，並在需要時輸出結果，提升效率與可讀性。
- 使用同一個 sum 變數，讓(a)與(b)兩部份共用累加狀態，避免重複計算，降低時間成本。
- 加入檔案頭註解，說明檔案名稱、功能、作者與日期，符合題目對備註的要求。
- 輸出格式改為符合題目要求：i 使用寬度為 6 的整數輸出，pi 保留小數點後 10 位，且每行用單一換行。
- 變數命名與註解：增加註解說明每段邏輯，並使用描述性變數名稱如 MAX_TERMS、TARGET_LOW、TARGET_HIGH、sum、term。

改進建議或反饋（一句話）：
建議在程式開頭加入完整的檔案頭註解並以單一累加迴圈實作，提高可讀性與執行效率，方便日後維護與擴展。
