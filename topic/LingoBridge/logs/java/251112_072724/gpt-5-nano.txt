總分：82

評分明細
- 正確性 (50%): 49/50
  - 作業要求的部分 (a) 與 (b) 的演算法思路正確，使用 Leibniz 級數計算 pi 的近似值，並依題意輸出指定格式。對於 (b) 的最小 i 之判斷採樣 truncation 到 5 位小數再比對，邏輯方向正確，雖然浮點比較在極小機率下可能略有風險，但在此題的情境下實作符合需求。
- 邏輯 (30%): 26/30
  - 具備直覺且可讀的邏輯，先逐步累加直到得到期望的 i，再單獨再跑一次找出使 pi 截至 5 位小數為 3.14159 的最小 i。整體結構清晰，但原作的雙重迴圈可再合併以提升邏輯連貫性與效率。
- 格式 (10%): 6/10
  - 原始程式變數命名較不具描述性，且註解不足，整體排版略混亂。輸出格式正確符合題目要求，但風格與一致性仍有提升空間。
- 備註 (10%): 1/10
  - 原程式缺乏程式標頭註解（檔案名稱、功能、作者、日期等），未提供適當說明。改寫版會補上標頭註解。

修改說明與優化後程式
以下為優化後的完整程式碼，並附上修改原因。新版本改用單一累加迴圈以避免重複計算、變數命名更具描述性、加入程式標頭註解、並以 printf 直接符合輸出格式。

修改後完整程式碼（LeibnizPi.java）：
/**
 * File: LeibnizPi.java
 * 功能: 計算 Leiniz 公式近似的 pi
 *      (a) 輸出 i = 10000, 20000, ..., 100000 對應的 pi 值，格式符合題目要求
 *      (b) 找出使 pi 截至 5 位小數等於 3.14159 的最小 i 值
 * 作者: 你的助教
 * 日期: 2025-11-11
 */
public class LeibnizPi {
    public static void main(String[] args) {
        final int MAX_TERMS = 100000; // 總計算項數上限
        final int STEP = 10000;       // 輸出间隔（每 10000 項輸出一次）

        double sum = 0.0;
        int sign = 1; // 第1項為正

        // Part (a): 輸出 i = 10000, 20000, ..., 100000 對應的 pi 值
        for (int k = 0; k < MAX_TERMS; k++) {
            sum += sign * (1.0 / (2 * k + 1));
            sign = -sign; // 下一項符號交替

            int terms = k + 1; // 當前項數 i
            if (terms % STEP == 0) {
                double pi = sum * 4.0;
                System.out.printf("i = %6d, pi = %.10f%n", terms, pi);
            }
        }

        // Part (b): 找出最小的 i，使 pi 截至 5 位小數等於 3.14159
        sum = 0.0;
        sign = 1;
        int k = 0;
        int minimalI = -1;
        while (true) {
            sum += sign * (1.0 / (2 * k + 1));
            double piVal = sum * 4.0;
            double truncPi = Math.floor(piVal * 1e5) / 1e5; // 截至 5 位小數
            if (truncPi == 3.14159) {
                minimalI = k + 1;
                break;
            }
            sign = -sign;
            k++;
        }
        System.out.printf("%ni = %6d%n", minimalI);
    }
}

修改部分原因與重點
- 效率與可讀性：改用單一累計迴圈逐步累加所有項，避免在每個 i 重新從頭計算，顯著提升效率，特別當 i 增大時。
- 變數命名與註解：使用描述性變數名稱（sum、sign、STEP、MAX_TERMS 等），並新增檔案標頭註解，提升可維護性與可讀性。
- 輸出格式：直接使用 System.out.printf 以符合題目固定格式需求，避免額外字串拼接的風險。
- (b) 判斷穩健性：以截斷到 5 位小數後再做相等比較的方式，較符合題意，並可避免部分因浮點誤差造成的非預期結果；仍保留原本的數值判斷邏輯。
- 維持符合題目要求的輸出格式與位數：i 顯示為六位寬度，pi 顯示為小數點後十位。

改進建議與反饋（一句話）
建議改採單一累加循環的方式逐步累計與重用先前結果，並加上明確註解與一致的命名，提高可讀性與效率，同時避免浮點比較的不穩定性。
