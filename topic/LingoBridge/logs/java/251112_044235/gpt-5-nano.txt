86

評分明細
- 正確性（50%）：50/50
  - (a) 能正確輸出 i=10000,20000,...,100000 各自的 pi 值，格式符合要求。
  - (b) 以穩健方式找出使 pi 四捨五入至小數第5位為 3.14159 的最小項數，並輸出該 i 值。
- 邏輯（30%）：28/30
  - (a) 以每次固定數量條項進行累加，邏輯清晰且正確。
  - (b) 原程式使用字串比對判斷精確等於 "3.1415900000" 的情況較脆弱；改以四捨五入判斷更正確地反映題意。
  - 整體設計良好，但原始版本未模組化，略微影響可讀性與重用性。
- 格式（10%）：8/10
  - 變數命名清楚、縮排整齊、輸出格式符合要求（i 以欄位寬度顯示，pi 以小數點後10位顯示）。
  - 原作未包含標頭註解，這部分在改版中補充。
- 備註（10%）：0/10
  - 原始程式缺少檔案標頭註解（檔案名稱、功能、作者、日期等）與適當說明，因此本次未給予備註分。

修改重點與說明
- 移除 Math.pow(-1, k) 的用法，改以符號翻轉 sign 方式產生正負號，提升執行效率並避免浮點運算誤差累積。
- 將計算分成兩個清晰的部分：一個用於 (a) 的多組 i 值的 pi 值計算、另一個用於 (b) 找出最小使 pi 四捨五入到 5 位小數為 3.14159 的項數，提升可讀性與重用性。
- (b) 改為以四捨五入判斷，而非字串比對，確保在浮點數近似下仍能穩健判斷是否符合 3.14159 的條件。
- 增加完整的檔案標頭與註解，提升可維護性與他人理解度。

修改後完整程式碼（已優化）
/*
 * File: LeibnizPi.java
 * 功能: 根據 Leibniz 公式計算圓周率近似值
 * 作者: 教師姓名
 * 日期: 2025-11-11
 * 說明: (a) 計算 i = 10000, 20000, ..., 100000 的 pi 近似值
 *       (b) 找出最小的項數使 pi 四捨五入到小數第5位為 3.14159
 */
public class LeibnizPi {
    public static void main(String[] args) {
        // (a) 輸出 i = 10000,20000,...,100000 的 pi 值
        for (int i = 10000; i <= 100000; i += 10000) {
            double pi = leibnizPi(i);
            System.out.printf("i = %6d, pi = %.10f%n", i, pi);
        }

        // (b) 找出最小的 i 使 pi 四捨五入至 5 位小數為 3.14159
        int minTerms = minTermsForPi3_14159();
        System.out.printf("i = %d%n", minTerms);
    }

    // 計算使用前 terms 個項的 Leibniz pi 近似值（4 * sum_{k=0}^{terms-1} (-1)^k / (2k+1)）
    private static double leibnizPi(int terms) {
        double sum = 0.0;
        int sign = 1;
        for (int k = 0; k < terms; k++) {
            sum += sign * (1.0 / (2 * k + 1));
            sign = -sign;
        }
        return 4.0 * sum;
    }

    // 找出最小的項數 n(從 1 開始)使 pi 近似值四捨五入到 5 位小數等於 3.14159
    private static int minTermsForPi3_14159() {
        double sum = 0.0;
        int n = 0; // n 為項數的零-based索引，實際項數為 n+1
        while (true) {
            sum += ((n % 2 == 0) ? 1.0 : -1.0) / (2 * n + 1);
            double piValue = 4.0 * sum;
            long rounded = Math.round(piValue * 1e5); // 四捨五入到 5 位小數
            if (rounded == 314159L) {
                return n + 1;
            }
            n++;
        }
    }
}

一句話改進建議
- 建議把兩個核心功能分成獨立方法，並以四捨五入判斷取代字串比對，能提升穩定性與可讀性，同時避免冗餘的浮點運算。
