4

以下為評分、修改後的完整程式與說明：

評分（依據你的標準，0-100）
- 正確性(50%): 0
  - 學生的程式與題目需求無關，未實作勒布尼茲級數、也未輸出指定格式。
- 邏輯(30%): 0
  - 程式邏輯與需求相去甚遠，無法正确計算或輸出結果。
- 格式(10%): 4
  - 基本可編譯，但命名與輸出格式不符合題目要求，且缺乏適當註解與一致縮排。
- 備註(10%): 0
  - 缺乏程式標頭註解與說明。

總結：4/100

修改後完整程式碼（符合題目要求，使用勒布尼茨級數近似 pi，並依照輸出格式要求輸出）
- 說明：程式分成兩部分。第一部分輸出 i 為 10000、20000、...、100000 時的 pi 值，pi 保留到小數點後10位，i 以寬度6對齊。第二部分找出最小的 i，使 pi 的近似值到小數點後 5 位符合 3.14159（容忍度 0.000005），並輸出該 i。程式包含適當的註解與標頭。

// File: PiLeibniz.java
// 功能: 使用勒布尼茨級數近似 pi，輸出在 i=10000, 20000, ..., 100000 的近似值（小數點後十位），
 // 以及最小的 i 使近似值為 3.14159（到小數第五位）的 i 值。
// 作者: 教師
// 日期: 2025-11-11

public class PiLeibniz {
    public static void main(String[] args) {
        // Part A: 逐步累加，輸出 i = 10000, 20000, ..., 100000 时的 pi 值
        double pi = 0.0;
        for (int i = 1; i <= 100000; i++) {
            // 第 i 項的符號為 (-1)^(i+1)，絕對值為 4/(2i-1)
            pi += (i % 2 == 1) ? 4.0 / (2 * i - 1) : -4.0 / (2 * i - 1);
            if (i % 10000 == 0) {
                // 使用寬度控制：i 宽度6，pi 保留小數點後10位
                System.out.printf("i = %6d, pi = %.10f%n", i, pi);
            }
        }

        // Part B: 找出最小的 i，使 pi 的近似值到小數點第 5 位為 3.14159
        double target = 3.14159;
        double sum = 0.0;
        int minI = 0;
        int maxIter = 2_000_000; // 安全上限，足以涵蓋題目範例中的 136121
        for (int i = 1; i <= maxIter; i++) {
            sum += (i % 2 == 1) ? 4.0 / (2 * i - 1) : -4.0 / (2 * i - 1);
            if (Math.abs(sum - target) < 0.000005) {
                minI = i;
                break;
            }
        }
        System.out.println("i = " + minI);
    }
}

修改原因與說明：
- 使用勒布尼茨級數的累加方式直接計算 pi，符合題目公式與性能需求，避免重複計算和不易讀的字串處理。
- 第 a 部分使用 System.out.printf，採用寬度控制 %6d 與小數點位數控制 %.10f，能滿足輸出格式的對齊與精度要求。
- 第 b 部分設定容忍度 0.000005，並在合理的上限內尋找最小 i，以對應題目要求「pi 等於 3.14159」的最小 i 值。
- 增加標頭註解，說明檔案名稱、功能與作者，提升可維護性；並保持適當的縮排與註解，提升可讀性。

改進建議或反饋（一句話）
- 建議將常數與輸出格式抽成常量/方法，並加入單元測試以驗證各階段的輸出是否符合格式與精度。
