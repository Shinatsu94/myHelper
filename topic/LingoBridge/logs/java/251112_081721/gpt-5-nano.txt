2
- 正確性(50%): 0
- 邏輯(30%): 0
- 格式(10%): 2
- 備註(10%): 0
總分: 2/100

修改說明與建議
- 修改說明
  1) 針對題意改成使用莱布尼茲級數直接計算 pi，並在 i = 10000, 20000, ..., 100000 時輸出對應的 pi 值，格式符合題意的輸出需求。
  2) 加入從 i = 100001 開始繼續累加，直到 pi >= 3.14159，取得最小的 i 值，並輸出該 i 值（僅輸出 i，不輸出 pi）。
  3) 移除原作業中與題意無關的輸入與判斷邏輯，使用更清晰的變數命名與註解，提升可讀性與可維護性。
  4) 輸出格式統一使用 System.out.printf，確保 i 以寬度6顯示，pi 小數點後10位，且每一行以換行結束，符合題目要求。
  5) 程式增加標頭註解，說明檔案名稱、功能、作者、日期，以及程式內的關鍵邏輯說明，提升可追蹤性。

- 修改的主要部分原因
  - 原程式與題目無關，僅判斷數字是否「自排」等與需求不符，未實作 pi 的計算與輸出。此次修改以題意為中心，實作正確的演算法與輸出格式。

- 改善的範例程式碼
以下為修改後的完整程式碼，請直接放入 .java 檔案執行。

public class LeibnizPiCalculator {
    /*
     File: LeibnizPiCalculator.java
     功能: 使用莱布尼茨級數計算圓周率的近似值，輸出 i = 10000, 20000, ..., 100000 對應的 pi 值，
           並找出使 pi >= 3.14159 的最小 i 值（僅輸出該 i）。
     作者: 輸入或自定
     日期: 2025-11-12
     */

    public static void main(String[] args) {
        // Phase 1: 計算 pi 的近似值，並輸出指定的 i 值
        final int N = 100000; // 最大要計算到的 i
        double piSum = 0.0;
        for (int i = 1; i <= N; i++) {
            int t = i - 1; // 對應級數的項次 t
            double term = 4.0 * (((t % 2) == 0) ? 1.0 : -1.0) / (2 * t + 1);
            piSum += term;
            if (i % 10000 == 0) {
                System.out.printf("i = %6d, pi = %.10f%n", i, piSum);
            }
        }

        // Phase 2: 找出最小的 i 使 pi >= 3.14159
        int k = N;
        while (piSum < 3.14159) {
            double term = 4.0 * (((k % 2) == 0) ? 1.0 : -1.0) / (2 * k + 1);
            piSum += term;
            k++;
        }
        System.out.printf("i = %d%n", k);
    }
}

一句話改進建議
- 建議在提交作業前，先確保程式能單獨執行並符合題目輸出格式與邏輯需求，再加入註解與標頭，能提升評分與可維護性。
