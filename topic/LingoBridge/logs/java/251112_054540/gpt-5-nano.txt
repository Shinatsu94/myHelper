5

- 正確性(50%): 0/50
- 邏輯(30%): 0/30
- 格式(10%): 3/10
- 備註(10%): 0/10
- 總分: 5/100

修改後的程式碼（完整可執行版本）
// 檔案名稱：LeibnizPi.java
// 功能：使用格雷戈里-萊布尼茲級數計算 pi，輸出 i = 10000, 20000, ..., 100000 時的 pi 值；並找出使 pi >= 3.14159 的最小 i。
// 作者：改良者
// 日期：2025-11-11
public class LeibnizPi {
    public static void main(String[] args) {
        // 使用累加法逐項累加，避免重複計算
        double s = 0.0; // 累加和，s = sum_{k=1..i} (-1)^{k-1} / (2k-1)
        for (int i = 1; i <= 100000; i++) {
            // 第 i 項：分子為 (-1)^{i-1}，分母為 (2i-1)
            double term = ((i % 2 == 1) ? 1.0 : -1.0) / (2.0 * i - 1.0);
            s += term;

            // 當 i 為 10000 的倍數時輸出結果
            if (i % 10000 == 0) {
                double pi = 4.0 * s;
                System.out.printf("i = %6d, pi = %.10f%n", i, pi);
            }
        }

        // 空一行分隔輸出區段，符合題目格式需求
        System.out.println();

        // 找出使 pi >= 3.14159 的最小 i
        double s2 = 0.0;
        int iMin = 0;
        for (int i = 1; ; i++) {
            s2 += ((i % 2 == 1) ? 1.0 : -1.0) / (2.0 * i - 1.0);
            double pi = 4.0 * s2;
            if (pi >= 3.14159) {
                iMin = i;
                break;
            }
        }
        System.out.println("i = " + iMin);
    }
}

修改說明與原因
- 將題目需求轉為實作：原學生程式與題意毫無關聯，無法輸出所需的 pi 計算結果，因此需要改成實作格雷戈里-萊布尼茲級數的正確演算法。
- 使用累加法進行逐項計算：與每次重新從頭計算 i 項相比，改為逐項累加，時間複雜度由 O(n^2) 降為 O(n)，效率提升顯著。
- 輸出格式與精度處理：使用 System.out.printf 配置 i 為 6 位右對齊，pi 為小數點後 10 位，符合題目要求的輸出格式；也確保第一段輸出與題目示例對齊。
- 程式結構與可讀性：加入完整註解、保留 header，變數命名採用更清晰的 camelCase，確保後續維護較容易。
- 去除與題意不相關的輸入處理：原程式使用 Scanner 讀取輸入並判斷整數序列之排序，與本題需求無關，已移除以避免干擾。

改進建議（一句話）
確保題意對齊與輸出格式完整再提交，並採用單次迭代累加的方式提升效率與可讀性。
