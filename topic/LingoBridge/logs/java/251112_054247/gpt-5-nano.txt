第1行：4

以下為修改後完整程式碼與修改說明。

修改後完整程式碼（新檔名建議：LeibnizPi.java）
/*
檔案名稱: LeibnizPi.java
功能說明: 使用莱布尼茨公式計算 pi，輸出 i=10000, 20000, ..., 100000 對應的 pi 值（Pi 需到小數點後10位，i 顯示為6位寬），
以及尋找最小的 i 使得 pi 近似值等於 3.14159 的最小 i，輸出格式依題目要求。
作者: 教師姓名
日期: 2025-11-11
*/

public class LeibnizPi {
    public static void main(String[] args) {
        // 使用累加方式，避免每次重新計算整個和的成本，對 i=1..100000 累加
        double sum = 0.0;
        for (int i = 1; i <= 100000; i++) {
            // 第 i 項的符號為 (-1)^(i-1)，分母為 2*i - 1
            double term = ((i % 2 == 1) ? 1.0 : -1.0) / (2.0 * i - 1);
            sum += term;

            // 每到 10000 的倍數輸出
            if (i % 10000 == 0) {
                double pi = 4.0 * sum;
                System.out.printf("i = %6d, pi = %.10f%n", i, pi);
            }
        }

        // Part (b): 找到最小的 i 使 pi 約等於 3.14159，誤差小於 1e-5
        double target = 3.14159;
        double s = 0.0;
        int iMin = 0;
        for (int i = 1; ; i++) {
            double t = ((i % 2 == 1) ? 1.0 : -1.0) / (2.0 * i - 1);
            s += t;
            double piVal = 4.0 * s;
            if (Math.abs(piVal - target) < 1e-5) {
                iMin = i;
                break;
            }
            // 安全容限，避免極端情況下無窮迴圈
            if (i > 2000000) {
                iMin = i;
                break;
            }
        }

        System.out.println();
        System.out.println("i = " + iMin);
    }
}

修改說明與原因
- 將原學生程式與題目需求差異明確化：原程式與題目無關，僅判斷數字的「位數有序性」。此次重寫以題目要求的 Leibniz 公式計算 pi 為核心，確保正確性。
- 計算效率提升：採用累加方式逐步累積前 i 項的和，並在 i 為 10000 的倍數時輸出結果，避免每次都從頭計算，提升效率。
- 輸出格式對應題目：使用 printf/format 方式確保 i 顯示為 6 位寬，pi 顯示到小數點後 10 位，並符合題目給的格式示例（包括輸出換行的排版）。
- 增加程式註解與標頭：加入檔案說明、功能、作者、日期等註解，符合備註評分項。
- 對於 (b) 的需求：新增最小 i 的計算，找出使 pi 與 3.14159 的差距小於 1e-5 的最小 i，並輸出該值，滿足題目的完整要求。

改進建議（單一句話）
- 建議在實務上再加上輸入參數化與單元測試，讓不同條件下的數值輸出也能自動驗證正確性與穩定性。

做法與原因說明的要點
- 使用累加避免重複計算，提升效率；-1/+1 的符號判定透過 i 的奇偶性直接決定，簡潔且易於維護；- 輸出格式選用固定寬度與小數點位數，符合題目輸出樣式。
