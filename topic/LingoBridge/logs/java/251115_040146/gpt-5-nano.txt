63

改進建議（概述一句話）
- 建議在輸出時以更穩健的規則處理接近於零的值，避免出現 -0.0000 或 0.0000 的情況，同時對不可逆情況做適當處理。

評分與評語
- 正確性 (50%): 25/50
  - 核心演算法正確，能計算出 3x3 矩陣的反矩陣，但對於某些輸出情況（例如最後一格等於 0 的情況，原始程式會輸出 0.0000 而非需求中的 0），未完全符合題目輸出規範，影響正確性判定。
- 邏輯 (30%): 28/30
  - 邏輯清晰，使用常見的伴隨矩陣/伴隶矩陣計算法，整體流程合理。
- 格式 (10%): 7/10
  - 基本縮排與命名具有可讀性，但可再加強變數命名與一致性風格，以及避免使用雜湊式的陣列建立方式。
- 備註 (10%): 3/10
  - 程式標頭含有個人學號、姓名等，但有不專業的語氣與未達成良好說明的註解，建議改成正式且清楚的說明與著作權資訊。

總評分：63/100

修改方向與說明（重點）
- 輸出格式改進：改用閾值判斷 Math.abs(v) < 0.00005 以判定近似為零，若為零就輸出 0；否則輸出四位小數，避免出現 -0.0000 或 0.0000 的問題。
- 程式結構微調：使用直接的 3x3 二維陣列宣告與填入，簡化程式碼。增加對 det 為 0 的情況的檢查，避免除以零的情況。
- 註解與格式：加強程式頭註解的專業性與可讀性，改善變數命名，使內容更易於理解與維護。

修改後完整程式碼
/
**
 * 程式名稱 : 反矩陣
 * 功能說明： 輸入3x3的矩陣，輸出其反矩陣，顯示到小數點後四位。
 * 僅當元素為 0 時，輸出 '0'（不顯示為小數）。
 * 日期: 2025/10/31
 * 姓名: 張竣傑
 * 學號: 41343224
 */

import java.util.Scanner;

public class CSIE_41343224_1031_4 {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // 使用直接宣告的 3x3 陣列
        double[][] a = new double[3][3];
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                // 讀入使用者輸入的元素，直接以 double 儲存
                a[i][j] = in.nextDouble();
            }
        }

        // 計算行列式 det
        double det = a[0][0] * (a[1][1] * a[2][2] - a[1][2] * a[2][1])
                   - a[0][1] * (a[1][0] * a[2][2] - a[1][2] * a[2][0])
                   + a[0][2] * (a[1][0] * a[2][1] - a[1][1] * a[2][0]);

        // 若行列式為 0，則無法求反矩陣，避免除以 0
        if (Math.abs(det) < 1e-12) {
            // 依題意未指定不可逆時的輸出，這裡選擇直接結束程序
            in.close();
            return;
        }

        // 計算反矩陣 inv
        double[][] inv = new double[3][3];
        inv[0][0] = (a[1][1] * a[2][2] - a[1][2] * a[2][1]) / det;
        inv[0][1] = (a[0][2] * a[2][1] - a[0][1] * a[2][2]) / det;
        inv[0][2] = (a[0][1] * a[1][2] - a[0][2] * a[1][1]) / det;

        inv[1][0] = (a[1][2] * a[2][0] - a[1][0] * a[2][2]) / det;
        inv[1][1] = (a[0][0] * a[2][2] - a[0][2] * a[2][0]) / det;
        inv[1][2] = (a[0][2] * a[1][0] - a[0][0] * a[1][2]) / det;

        inv[2][0] = (a[1][0] * a[2][1] - a[1][1] * a[2][0]) / det;
        inv[2][1] = (a[0][1] * a[2][0] - a[0][0] * a[2][1]) / det;
        inv[2][2] = (a[0][0] * a[1][1] - a[0][1] * a[1][0]) / det;

        // 輸出反矩陣：近似為零時輸出 0，其他則輸出 4 位小數
        double epsZero = 0.00005;
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                double v = inv[i][j];
                if (Math.abs(v) < epsZero) {
                    System.out.print("0");
                } else {
                    System.out.printf("%.4f", v);
                }
                if (j < 2) System.out.print(" "); // 每列元素之間的空格
            }
            if (i < 2) System.out.print("\n"); // 換行，前三行結束時換行
        }

        System.out.println(); // 確保檔案結尾有換行
        in.close();
    }
}
