2

- 正確性: 0/50
- 邏輯: 0/30
- 格式: 2/10
- 備註: 0/10
總分: 2

修改與說明
- 問題重點在於使用勒布尼茲級數計算 pi，並輸出 i 為 10000, 20000, ..., 100000 時對應的 pi，且再找出使 pi 達到 3.14159 的最小 i（以項數表示）。原始程式只是做了數字反轉，與題意嚴重不符。
- 新程式會依序累加勒布尼茲級數的項，當 i 為 10000、20000、…、100000 時輸出 pi（格式符合「i = 6位數, pi = 小數點後10位」的需求），之後再延伸計算直到找到使 pi >= 3.14159 的最小 i，並另外輸出該 i。並加入程式標頭註解、良好命名與適當注解，提升可讀性與可維護性。

修改後完整程式碼（已優化並符合題意）：
// File: LeibnizPi.java
// 功能: 使用勒布尼茲級數計算 pi 的近似值。輸出 i = 10000, 20000, ..., 100000 對應的 pi 值，
//      並找出使 pi >= 3.14159 的最小 i（以項數表示）。
// 作者: 教授
// 日期: 2025-11-11

import java.util.Locale;

public class LeibnizPi {
    public static void main(String[] args) {
        Locale.setDefault(Locale.US); // 確保小數點使用 "." 而非逗號

        final int STEP = 10000;
        final int MAX_I = 100000;

        double sum = 0.0;
        int kIndex;

        // 第一部分：輸出 i = 10000, 20000, ..., 100000 的 pi 值
        for (kIndex = 0; kIndex < MAX_I; kIndex++) {
            double term = ((kIndex % 2 == 0) ? 1.0 : -1.0) / (2.0 * kIndex + 1.0);
            sum += term;
            int i = kIndex + 1; // 計算到的項數
            if (i % STEP == 0) {
                double pi = 4.0 * sum;
                System.out.printf("i = %6d, pi = %.10f%n", i, pi);
            }
        }

        // 空行分隔
        System.out.println();

        // 第二部分：找出最小的 i 使 pi >= 3.14159
        double target = 3.14159;
        int iMin = -1;

        // 從下一項開始繼續累加，kIndex 代表項數的索引 (從 MAX_I 開始)
        int k = MAX_I;
        while (true) {
            double term = ((k % 2 == 0) ? 1.0 : -1.0) / (2.0 * k + 1.0);
            sum += term;
            double pi = 4.0 * sum;
            // i 代表實際的項數為 k + 1
            if (pi >= target) {
                iMin = k + 1;
                break;
            }
            k++;
            // 安全機制，實務上不太會到這裡
            if (k > 200000000) break;
        }

        System.out.println("i = " + iMin);
    }
}

修改部分的原因
- 重新實作為勒布尼茲級數計算，符合題目要求的輸出格式與內容，並避免不必要的重新計算，提升運算效率與可讀性。
- 加入標頭註解、清晰的變數命名與分段說明，提升維護性與可讀性。
- 使用格式化輸出確保 i 以六位寬度顯示、pi 顯示到小數點後十位，符合題目要求的輸出格式。

改進建議或反饋（一句話）
- 建議在正式作業中，將演算法流程以伺服器自動化測試（用不同 STEP、不同閾值）驗證輸出是否正確，並加入單元測試以避免日後修改破壞輸出格式與邏輯正確性。
