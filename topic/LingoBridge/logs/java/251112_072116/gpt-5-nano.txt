98

修改後完整程式碼（已優化與修正輸出格式，並補上程式檔案註解與更清晰的結構）：

/**
 * 文件名稱: LeibnizPi.java
 * 功能說明: 利用勒布尼茲公式近似 pi，分成兩部分輸出：
 *           (a) i = 10000, 20000, ..., 100000 時的 pi 值（到小數點後10位）
 *           (b) 找到最小的 i，使 pi >= 3.14159，僅輸出該 i（格式為 i = 六位寬度）
 * 作者: 教授
 * 日期: 2025-11-11
 * 備註: 程式包含註解以說明邏輯，並遵循輸出格式要求。
 */
public class LeibnizPi {
    public static void main(String[] args) {
        int limit = 100000;
        double sum = 0.0;

        // (a) 逐步累加，並在 i 為 10000 的倍數時輸出 pi 值(sum*4)
        int nextPrint = 10000;
        for (int i = 1; i <= limit; i++) {
            sum += term(i);
            if (i == nextPrint) {
                System.out.printf("i = %6d, pi = %.10f%n", i, sum * 4.0);
                nextPrint += 10000;
            }
        }

        System.out.println();

        // (b) 從 limit 開始繼續累加，找最小 i 使 pi*4 >= 3.14159
        int i2 = limit;
        while (sum * 4.0 < 3.14159) {
            i2++;
            sum += term(i2);
        }

        // 只輸出 i，格式為六位寬度
        System.out.printf("i = %6d%n", i2);
    }

    // 第 i 項的值：若 i 為奇數，為 +1/(2i-1)；若偶數，為 -1/(2i-1)
    private static double term(int i) {
        return ((i & 1) == 1) ? 1.0 / (2.0 * i - 1.0) : -1.0 / (2.0 * i - 1.0);
    }
}

修改說明（與原始程式相比的重點改動）：
- 增設完整檔案註解與標頭，符合「備註」欄位的要求，包含檔案名稱、功能、作者與日期，提升可維護性。
- 以單一累加變數 sum，逐步累加勒布尼茲級數，並在 i 達到 10000 的倍數時輸出 pi 值，減少不必要重複計算。
- 對於題目 (b)，改為沿用同一個 sum 變數繼續累加，找出最小 i 使 pi >= 3.14159；輸出僅為 i，符合題目輸出格式要求。
- 輸出格式調整為使用 %6d 以符合示例中的對齊效果（i 以六位寬度輸出），以及 pi 以 %.10f 輸出到小數點後10位，確保與題目樣例一致。
- 將計算與輸出分離，加入清晰的註解、並將邏輯抽成 helper 函數 term(i) 以提高可讀性與維護性。

一句話改進建議/反饋：
建議進一步把輸出格式完全與題目樣例對齊（例如確定 i 的寬度與是否使用前導位元），並在必要時再將輸出收斂到單一流程，提升一致性與可維護性。
