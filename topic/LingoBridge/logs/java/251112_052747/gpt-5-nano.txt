2

打分明細
- 正確性 (50%): 0
- 邏輯 (30%): 0
- 格式 (10%): 2
- 備註 (10%): 0
總分 = 2/100

修改與說明
學生原程式與題目需求完全不符，僅做了一個數字位序判斷，與計算 pi 的系列求和無關。以下提供改寫版本，符合題意：計算 Lehmer/Leibniz 公式 pi = 4 * sum_{k=0}^{i-1} (-1)^k / (2k+1)，輸出 i 依序為 10000、20000、…、100000 的 pi 值，並找出使 pi >= 3.14159 的最小 i 值；同時符合輸出格式與註解要求。

- 移除輸入與無關判斷，直接計算。
- 以逐步累加的方式進行求和，避免重複計算，提高效率。
- 輸出格式使用寬度控制，i 以六位寬度對齊，pi 使用十位小數，符合題目示例。
- 加入適當的程式標頭註解，變數命名更有意義。
- 程式結構單純，易於閱讀與維護。

修改後完整程式碼
/**
 * File: LeibnizPi.java
 * 功能: 計算 Lehimbiz/Leibniz 公式求 pi，輸出 i=10000,20000,...,100000 對應的 pi 值，
 *       以及找出使 pi >= 3.14159 的最小 i。
 * 作者: 教師
 * 日期: 2025-11-11
 */
public class LeibnizPi {
    public static void main(String[] args) {
        // 第一部分: 輸出 i 從 10000到100000，步進10000 的 pi 值
        double sum = 0.0;
        int maxI = 100000;
        for (int i = 1; i <= maxI; i++) {
            // 第 i 項對應於 k = i-1，符號正負由 i 的奇偶決定
            double term = ((i % 2 == 1) ? 1.0 : -1.0) / (2.0 * i - 1.0);
            sum += term;
            if (i % 10000 == 0) {
                double pi = 4.0 * sum;
                // i 以六位寬度對齊，pi 顯示到小數點後10位
                System.out.printf("i = %6d, pi = %.10f%n", i, pi);
            }
        }

        // 第二部分: 找出最小的 i 使 pi >= 3.14159
        sum = 0.0;
        int minI = -1;
        double target = 3.14159;
        for (int i = 1; ; i++) {
            double term = ((i % 2 == 1) ? 1.0 : -1.0) / (2.0 * i - 1.0);
            sum += term;
            double pi = 4.0 * sum;
            if (pi >= target) {
                minI = i;
                break;
            }
        }
        System.out.println("i = " + minI);
    }
}

說明修改部分的原因
- 直接依題目需求實作，解決方案對應題目可輸出指定格式的結果，並將最小 i 的計算也納入。
- 以逐步累加的方式計算，避免重新計算整個和，提升效率與穩定性。
- 使用 System.out.printf 進行格式化，確保輸出符合題目中 i 的位數與 pi 的小數位數要求。
- 增加程式標頭與註解，提升可讀性與維護性。

改進建議或反饋（一句話）
建議在實作中加入適當的單元測試以驗證不同 i 的 pi 值是否符合預期，並考慮將輸出格式與資料來源集中管理，方便未來調整。
