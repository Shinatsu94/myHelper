3

作業評分

- 正確性: 0/50
- 邏輯: 0/30
- 格式: 3/10
- 備註: 0/10
總分：3/100

修改後的完整程式碼（可直接複製執行）

/*
檔案名稱：LeibnizPi.java
功能：計算對於題目給定的 i 值（每 10000 增加直到 100000）之 pi 值，
並找出 pi = 3.14159 最小的 i 值。採用李蔔尼茲級數：pi = 4 sum_{k=0}^{i-1} (-1)^k /(2k+1)
作者：學生
日期：請自行填寫
說明：輸出格式依題目要求，pi 顯示小數點後 10 位，i 顯示為6位寬度。
*/

import java.util.*;

public class LeibnizPi {
    public static void main(String[] args) {
        double pi = 0.0;

        // Part (a): i 從 1 增加到 100000，每 10000 輸出一次
        // 注意：題目中的 i 為項數，因此第 i 項對應的分母為 (2*(i-1) + 1)
        for (int i = 1; i <= 100000; i++) {
            double term = 4.0 * (((i - 1) % 2 == 0) ? 1.0 : -1.0) / (2 * (i - 1) + 1);
            pi += term;
            if (i % 10000 == 0) {
                System.out.printf("i = %6d, pi = %.10f%n", i, pi);
            }
        }

        // Part (b): 找出最小的 i 使得 pi 近似到 3.14159（四捨五入到小數點後5位）
        System.out.println();

        // 重新開始累加，或直接從上一步的 pi 值繼續累加更後面的項
        int i = 100000;
        // 從上一個 pi 值繼續累加直到滿足條件
        while (true) {
            i++;
            double term = 4.0 * (((i - 1) % 2 == 0) ? 1.0 : -1.0) / (2 * (i - 1) + 1);
            pi += term;
            if (Math.round(pi * 100000.0) == 314159) { // 3.14159 的 5 位小數的四捨五入值
                System.out.printf("i = %6d%n", i);
                break;
            }
            // 安全性：實務上可加上上限避免無限迴圈
            // if (i > 1000000) { System.out.println("未找到符合條件的 i"); break; }
        }
    }
}

說明與修改要點

- 正確性方面：
  - 原始作業僅做「數字排序檢查」，與題目計算 pi 的需求毫不相關，因此必須換成計算李蔔尼茲級數的實作，才能得到題目所需的輸出。
  - 新版本以逐次累加的方式計算 pi，並在每 10000 增加時輸出 i 與 pi，符合部份(a)的輸出格式與精度要求。

- 邏輯方面：
  - 使用 i 代表項數，對應分母 2(i-1)+1。這樣可以用簡單的循環達成「每次加入一項」的累加，並且方便對 10000、20000、…、100000 顯示中間結果。
  - Part (b) 從 i = 100000 開始接續累加，直到 pi 四捨五入到小數點後五位為 3.14159，符合題意尋找最小 i 的要求。

- 格式方面：
  - 輸出格式使用固定寬度 i 顯示（%6d）以及 pi 的小數點後 10 位（%.10f），使輸出符合題目給定的顯示格式。
  - 程式包含註解與檔案說明，提升可讀性。
  - 本版本避免不必要的輸入輸出，直接按照題意輸出，避免干擾。

- 備註方面：
  - 原始程式缺乏標頭註解與檔案資訊，新的版本在檔案開頭加入了註解說明檔案名稱、功能、作者與日期等，提升可維護性。

一語話改進建議

- 建議在實作中引入單元測試或分段驗證：先驗證第 10000、20000、… 的輸出是否與題目樣例相符，再單獨驗證找到的最小 i 是否正確，以提高程式可靠性與可維護性。
