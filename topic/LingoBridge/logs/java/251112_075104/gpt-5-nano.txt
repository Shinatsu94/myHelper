3

评分與評語：
- 正確性 (0/50)：學生的程式與題目需求毫不相符，根本無法輸出題意的 pi 值與 i 值，故正確性為 0。
- 邏輯 (0/30)：程式邏輯與題意無關，僅做數字排序檢查，屬於完全錯誤的方向，故邏輯0。
- 格式 (3/10)：有基本的程式結構與縮排，能編譯；但缺乏清楚的程式標頭註解、命名不夠清晰，且未依題意輸出指定格式與輸出內容，故給予 3/10。
- 備註 (0/10)：未包含檔案標頭註解、註解說明；故 0。

修改後的完整程式碼與說明如下：

修改後程式碼（完整可直接執行）：
/*
 * 程式名稱: LeibnizPi.java
 * 功能說明: 使用 Léibniz 公式近似 pi; 輸出 i = 10000, 20000, ..., 100000 時的 pi 值，pi 取到小數點後十位；再找出最小的 i 使 pi 四捨五入到小數點第5位等於 3.14159。
 * 作者: 教授
 * 日期: 2025-11-11
 */
public class LeibnizPi {
    public static void main(String[] args) {
        // Part (a): 輸出 i = 10000, 20000, ..., 100000 的 pi 值
        double sum = 0.0;
        int maxI = 100000;
        for (int i = 1; i <= maxI; i++) {
            double term = ((i % 2 == 1) ? 1.0 : -1.0) / (2.0 * i - 1.0);
            sum += term;
            if (i % 10000 == 0) {
                double pi = sum * 4.0;
                // i 要以六位數輸出，pi 輸出到小數點後十位
                System.out.printf("i = %6d, pi = %.10f%n", i, pi);
            }
        }

        // Part (b): 找到最小的 i 使 pi 四捨五入到小數點第5位為 3.14159
        sum = 0.0;
        long iMin = -1;
        for (int i = 1; i <= 2000000; i++) { // 安全上限
            double term = ((i % 2 == 1) ? 1.0 : -1.0) / (2.0 * i - 1.0);
            sum += term;
            long r = Math.round(sum * 100000.0); // 四捨五入至小數點第5位
            if (r == 314159L) {
                iMin = i;
                break;
            }
        }
        System.out.println("i = " + iMin);
    }
}

修改部分與原因說明：
- 目的改變：把學生原本的數字排序檢查程式改成解這道「Leibniz 公式近似圓周率」的程式，符合題目的要求。
- 輸出格式：使用格式化輸出，i 使用寬度六的右對齊（%6d），pi 使用小數點後十位（%.10f），符合題目給定的輸出格式與對齊要求。
- 輸入與結構：移除不需要的 Scanner 輸入，改為直接計算與輸出，避免外部輸入干擾。
- 設計與可讀性：加入程式標頭註解，使用清晰的類別名稱（LeibnizPi），並在主要區塊做分段註解，提升可維護性與可讀性。

一句話改進建議：
- 在提交前務必逐條對照題意與輸出格式，避免脫離題目需求，同時補齊檔案標頭註解與適當的程式註解以提升可維護性。
