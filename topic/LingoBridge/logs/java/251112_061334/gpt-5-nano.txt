3

評分明細
- 正確性（50%）: 0/50
  - 學生的程式與題目無關，未實作 pi 的近似與輸出格式要求，故判定為錯誤。
- 邏輯（30%）: 0/30
  - 題目要求與實作邏輯毫無關聯，缺乏規劃與演算法設計。
- 格式（10%）: 3/10
  - 程式雖可編譯，但命名不具描述性，且未使用適當註解與標頭說明，整體樣式不佳，略具基本排版。
- 備註（10%）: 0/10
  - 缺乏檔案標頭註解（檔名、功能、作者、日期等）與內容註解。

修改後的完整程式碼（優化並符合題意）

/*
檔案名稱: LeibnizPi.java
檔案功能: 利用勒貝格級數近似圓周率 pi，輸出在 i=10000,20000,...,100000 時的 pi 值，並尋找使 pi 約等於 3.14159 的最小 i。
作者: 教師示例
日期: 2025-11-11
說明: 以 4 * sum_{k=1..i} (-1)^(k-1) / (2k-1) 計算 pi；(a) 每隔 10000 輸出 pi，(b) 找到最小 i 使 pi 與 3.14159 的絕對誤差小於 5e-6，並輸出該 i 值。
*/

public class LeibnizPi {
    public static void main(String[] args) {
        // (a) 逐步累加直到 i = 100000，每 10000 輸出 pi，pi 顯示到小數點後 10 位，i 顯示到 6 位
        double sum = 0.0;
        int maxI = 100000;
        int interval = 10000;
        for (int i = 1; i <= maxI; i++) {
            double term = ((i % 2 == 1) ? 1.0 : -1.0) / (2.0 * i - 1.0);
            sum += term;
            if (i % interval == 0) {
                double pi = 4.0 * sum;
                System.out.printf("i = %6d, pi = %.10f%n", i, pi);
            }
        }

        // (b) 找出使 pi 接近 3.14159 的最小 i（絕對誤差 < 5e-6 即視為符合）
        double target = 3.14159;
        double sumB = 0.0;
        int minI = -1;
        int upper = 2000000; // 上限，避免無限迴圈
        for (int i = 1; i <= upper; i++) {
            double term = ((i % 2 == 1) ? 1.0 : -1.0) / (2.0 * i - 1.0);
            sumB += term;
            double piVal = 4.0 * sumB;
            if (Math.abs(piVal - target) < 5e-6) {
                minI = i;
                break;
            }
        }
        if (minI != -1) {
            System.out.println("i = " + minI);
        } else {
            System.out.println("i not found within upper bound");
        }
    }
}

修改原因與說明
- 跟題目需求對齊：原 Student 代碼與題意嚴重不符，僅是與數字排序相關的練習。重新撰寫實作，直接完成題目需求的數值計算與輸出格式。
- 演算法設計：採用勒貝格級數的逐項累加法，避免重複計算，並以 i 作為項數，逐步輸出在指定 i 值下的近似 pi 值。
- 輸出格式：使用格式化輸出 printf，確保 i 顯示為六位寬度、pi 顯示十位小數，與題目樣本一致；部分輸出（第 2 部分）維持與樣本一致的輸出形式。
- 程式可讀性與維護性：加上檔案標頭註解、分段註解與清楚的變數命名，方便日後維護與理解。

一語話改進建議
- 建議將演算法與輸出邏輯清楚分離，並配合單元測試驗證不同區間輸出與收斂情況，同時加入適當的例外處理與輸出格式說明，提升可維護性與可擴充性。

若需要，我可以提供另外版本的實作，支援自訂輸出間隔與容忍度，或以物件導向方式組成更易於單元測試的模組。
