0

程式修改後完整程式碼如下（含完整註解、符合題目輸出格式與邏輯）：

/*
 * 檔案名稱: LeibnizPi.java
 * 功能說明: 使用莱布尼茲級數近似圓周率
 *         (a) 輸出 i = 10000, 20000, ..., 100000 時的 pi 值，格式符合題目要求
 *         (b) 找出最小的 i，使 pi 的四捨五入到小數點後五位等於 3.14159
 * 作者: 教師
 * 日期: 2025-11-12
 */

public class LeibnizPi {
    public static void main(String[] args) {
        // (a) 計算並輸出 i=10000, 20000, ..., 100000 的 pi 值
        double sum = 0.0;
        int limit = 100000;
        int sign = 1; // 第1項為正，之後交替正負

        for (int i = 1; i <= limit; i++) {
            sum += sign * (1.0 / (2 * i - 1));
            sign = -sign;

            // 當 i 為 10000 的倍數時輸出
            if (i % 10000 == 0) {
                double pi = 4.0 * sum;
                System.out.printf("i = %6d, pi = %.10f%n", i, pi);
            }
        }

        // 與題目格式對齊，分隔線之用的空行
        System.out.println();

        // (b) 找到最小的 i，使 pi 四捨五入到小數點後五位等於 3.14159
        sum = 0.0;
        sign = 1;
        int iTarget = 0;
        for (int i = 1; ; i++) {
            sum += sign * (1.0 / (2 * i - 1));
            sign = -sign;
            double pi = 4.0 * sum;
            double roundedToFive = Math.round(pi * 100000.0) / 100000.0;
            if (roundedToFive == 3.14159) {
                iTarget = i;
                break;
            }
        }
        System.out.println("i = " + iTarget);
    }
}

修改原因說明：
- 正確性與邏輯：原始程式與題意不符，未計算 pi 或輸出指定格式。本版採用正統的莱布尼茲級數逐項累加，直接得到 pi 的近似值，並以 i 的倍數輸出需求結果，符合題目(a)與(b)的需求。
- 效能與穩定性：使用逐次累加的方式避免不必要的開銷（如多次調用 Math.pow），並使用 double 提升浮點計算穩定性，適合計算到 i=100000 的情況。
- 輸出格式與可讀性：使用 System.out.printf 搭配格式字串，確保 i 以固定寬度輸出（6 位數對齊）與 pi 小數點後總是 10 位，與題目輸出完全一致；並在結尾給出分隔空行與最終結果行。
- 程式標頭與註解：新增檔案註解，說明檔案名稱、功能、作者與日期，並在程式內容適當加入說明性註解，提升可讀性與維護性。

改進建議或反饋（一句話）：
- 建議在正式提交時，將輸出型態與格式嚴格對齊題目要求，並考慮將難度分段處理與自動化測試，以避免手動驗證的誤差。
