93

評分與分析
- 正確性（50%）: 程式正確地以 Leibniz 公式計算 pi 的近似值，並輸出每隔 10000 組成的 i 與 pi；同時在 pi 接近 3.14159（以 0.00001 的精度範圍判斷）時輸出最小的 i，符合題意。評分：50/50
- 邏輯（30%）: 邏輯簡潔清楚，使用符號位元運算避免多餘的模運算，順序與條件判斷清楚；能正確在指定條件下停止並輸出。評分：30/30
- 格式（10%）: 程式碼整體縮排尚可、使用有意義的變數名（pi、term、i），但程式標頭註解內容不足以符合要求的「檔案名稱、功能、作者、日期」等規範，且缺少較完善的內部註解。評分：8/10
- 備註（10%）: 程式標頭僅含姓名與學號，缺少檔案名稱、功能描述、日期等資訊，且缺乏適當的內容註解。評分：4/10

修改說明與優化
- 新增標頭與註解：加入完整程式檔案註解（檔案名稱、功能、作者、日期），提升可維護性與可讀性。
- 統一輸出格式與常量：使用常量/易讀變數取代硬編碼，並以清楚的格式輸出「i = 6位數, pi = 小數點後10位」。
- 提升可讀性與穩定性：
  - 將符號決定改用位元運算 (i & 1) 以提升效率，雖然在此情境差異微小但可見於培養良好習慣。
  - 將迴圈條件與輸出條件分離，且保留原有的輸出需求（每 10000 為一組輸出、最小 i 达到 pi 3.14159 的輸出）。
- 保持原功能同時清晰化：改寫後仍以原題要求的輸出格式輸出，並保留結尾輸出“i = …”的單獨行，符合題目輸出樣式。

修改後完整程式碼
public class LeibnizPi {
    /*
     File: LeibnizPi.java
     功能: 使用 Leibniz 公式近似計算圓周率 Pi，輸出每 10000 個項次的結果與最小符合 pi ≈ 3.14159 的 i 值。
     作者: 你的姓名
     日期: 2025-11-11
    */
    public static void main(String[] args) {
        double pi = 0.0;
        final int MAX_TERMS = 1000000;       // 安全的上限
        final int PRINT_INTERVAL = 10000;    // 每多少項輸出一次
        final int TARGET_LIMIT = 100000;     // part (a) 輸出到的最大 i 值
        final double TARGET_PI = 3.14159;    // 目標近似值
        for (int i = 0; i < MAX_TERMS; i++) {
            double term = 4.0 / (2 * i + 1);
            if ((i & 1) == 0) {
                pi += term;
            } else {
                pi -= term;
            }

            int termsUsed = i + 1;
            if (termsUsed % PRINT_INTERVAL == 0 && termsUsed <= TARGET_LIMIT) {
                System.out.printf("i = %6d, pi = %.10f\n", termsUsed, pi);
            }

            // 找到最小的 i 使 pi 的前五位小數等於 3.14159（以 1e-5 的判斷範圍）
            if ((int)(pi * 100000) == 314159) {
                System.out.printf("\ni = %6d", termsUsed);
                break;
            }
        }
    }
}

說明修改部分的原因
- 增加頭部註解與檔案資訊，提升可維護性與可讀性。
- 改用常量與清楚的變數名稱，讓程式意圖更易於理解，利於後續維護。
- 使用位元運算判斷奇偶性，提升微小的執行效率並養成良好習慣。
- 保留原輸出格式與結構，確保與測試樣本一致。

改進建議（一句話）
- 建議在實作中把輸出與計算邏輯分離成方法，以便擴充與測試，也可考慮把「part (a) 與 part (b)」拆成獨立方法呼叫，提升模組化與可維護性。
