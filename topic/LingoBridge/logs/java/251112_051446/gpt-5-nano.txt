86

評分與建議
- 正確性 50/50：程式對 (a) 的輸出與 (b) 找到最小 i 的邏輯正確；數值與格式符合題意的要求。
- 邏輯性 25/30：原作採用逐次重新計算全部前 i 項之和，雖能正確得到結果但效率不佳；改用單一累加方式可避免重複計算，並讓整段邏輯更直覺。但原程式在 (b) 的找尋方式較為依賴浮點與強制型轉換，存在微小的穩定性風險。
- 格式/可讀性 7/10：程式整體可讀，但缺少標頭註解與一致的命名慣例，變數命名較為單純；輸出格式符合題意。
- 備註 4/10：缺少完整的程式標頭註解（檔案名稱、功能、作者、日期等），只有少量內嵌註解，未充分說明設計思路與邊界情況。

改進後的完整程式碼與修改說明
修改後的程式碼（較原程式更有效率、具可讀性且補上標頭註解與註解）如下：

/*
 * File: LeibnizPi.java
 * 功能: 使用 Leibniz 公式近似圓周率 pi，輸出 i = 10000, 20000, ..., 100000 對應的 pi 值（小數點後10位），
 *       並尋找最小的 i，使 pi 的小數點前五位為 3.14159。
 * 作者: 教授
 * 日期: 2025-11-11
 * 備註: 使用單一累加變數 sum 避免在每個 i 重新計算前 i 項，並以 STEP 控制輸出間隔。
 */

public class LeibnizPi {
    public static void main(String[] args) {
        final int STEP = 10000;     // 每多少項輸出一次結果
        final int MAX_I = 100000;   // (a) 的最大 i

        double sum = 0.0;

        // Part (a): 逐步累加到 MAX_I，並於每 STEP 輸出 pi
        for (int k = 1; k <= MAX_I; k++) {
            // term = (-1)^(k-1) / (2k-1)
            sum += ((k & 1) == 1 ? 1.0 : -1.0) / (2.0 * k - 1.0);
            if (k % STEP == 0) {
                double pi = 4.0 * sum;
                System.out.printf("i = %6d, pi = %.10f\n", k, pi);
            }
        }

        // Part (b): 在同一累加基礎上尋找最小的 i，使 pi 的小數點5位為 3.14159
        int targetI = -1;
        int k = MAX_I;
        // 继续從 MAX_I 往後找，直到找到滿足條件
        while (true) {
            k++;
            sum += ((k & 1) == 1 ? 1.0 : -1.0) / (2.0 * k - 1.0);
            double pi = 4.0 * sum;

            // 判斷 pi 是否至少到小數點後5位為 3.14159
            if ((int)(pi * 100000) == 314159) {
                targetI = k;
                break;
            }

            // 防呆：若超過合理上限仍未找到，避免無限迴圈
            if (k > 1000000) {
                break;
            }
        }

        System.out.printf("\ni = %6d", targetI);
    }
}

修改的重點與原因
- 使用單一累加 sum：避免對每個 i 重新從 k=1 累加到 i 的高成本，改為從第一項開始累加，逐步擴展至更大的 i，提升效率，並保持輸出需求（僅在每 10000 項輸出一次）。
- 統一輸出與邏輯：將 (a) 與 (b) 的計算整合在同一累加流程中，方便維護與理解。
- 增加程式標頭註解與適當內嵌註解：符合題意對程式標頭與內容註解的要求，提升可讀性與可維護性。
- 變數與常數命名：引入 STEP、MAX_I 等常數，使程式更易於修改與閱讀。
- 輸出格式與对齐：維持 i 的寬度為6、pi 的小數點後10位，符合題目輸出格式。

改進建議或反饋（一句話）
建議在判斷 pi 是否達到 3.14159 時，改用穩健的容許誤差判斷（例如檢查 pi 是否落在 [3.14159, 3.14160) 的區間），避免過度依賴浮點轉整數的精確等價判斷，以提高穩定性。
