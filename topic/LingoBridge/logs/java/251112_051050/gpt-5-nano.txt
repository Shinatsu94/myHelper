16

- 正確性（50%）：0/50
  這份作業的提交在實作與語法層面無法正確執行。原始程式在第二部分 (找出最小的 i 使 pi 逼近 3.14159) 存在嚴重語法錯誤（如缺失的字串結尾與未完成的輸出格式），且邏輯上也未以穩定且可驗證的方式達成題意，整份程式無法正確編譯與執行。

- 邏輯（30%）：12/30
  優點：一開始的勒布尼茲級數計算與分步輸出部分的邏輯與公式相符，能得到 i=10000、20000、…、100000 的 pi 值並以指定格式輸出。  
  缺點：第二部分的設計不完善，使用不正確的條件與浮點比對，且無限迴圈保護機制，容易造成執行失敗或無法預期的結果。整體邏輯需要重構以符合題意且具可驗證性。

- 格式（10%）：4/10
  優點：基本縮排與變數命名還算清楚，輸出格式接近題意（i 為 6 位寬、pi 為小數點後 10 位）。  
  缺點：缺少程式標頭註解（檔案名稱、功能、作者、日期等），且第二部分的程式片段有語法錯誤，影響可讀性與可維護性。

- 備註（10%）：0/10
  未提供任何程式標頭註解或內部註解，未說明檔案目的、作者或日期。

總分: 16/100

以下提供一份經過修改與優化的完整可執行範例程式碼，以及修改說明與改進建議。

修改後的完整程式碼（可直接在 Java 環境執行）：
// 檔案名稱: LeibnizPi.java
// 功能: 
//   (a) 計算 pi = 4 * sum_{k=1..N} (-1)^{k+1} / (2k-1) 在 i=10000,20000,...,100000 時的值
//   (b) 找出最小的 i，使 pi 的五位小數為 3.14159
// 作者: 你的姓名
// 日期: 2025-11-11

public class LeibnizPi {
    public static void main(String[] args) {
        // Part (a): i = 10000, 20000, ..., 100000
        int maxCheck = 100000;
        int step = 10000;
        double sum = 0.0;

        for (int i = 1; i <= maxCheck; i++) {
            double term = 1.0 / (2 * i - 1);
            if (i % 2 == 0) {
                sum -= term;
            } else {
                sum += term;
            }

            if (i % step == 0) {
                double pi = 4.0 * sum;
                System.out.printf("i = %6d, pi = %.10f%n", i, pi);
            }
        }

        // 空白行，符合輸出分段的需求
        System.out.println();

        // Part (b): 找到最小的 i 使 pi 的五位小數為 3.14159
        sum = 0.0;
        int i = 1;
        while (true) {
            double term = 1.0 / (2 * i - 1);
            if (i % 2 == 0) {
                sum -= term;
            } else {
                sum += term;
            }

            double pi = 4.0 * sum;
            // 以 5 位小數作為比較基準，避免直接比較浮點數帶來的問題
            double rounded5 = Math.round(pi * 100000.0) / 100000.0;
            if (rounded5 == 3.14159) {
                System.out.printf("i = %6d%n", i);
                break;
            }

            i++;
            // 防護機制，避免極端情況下的無窮迴圈
            if (i > 2_000_000) {
                System.out.println("Unable to determine minimal i within limit.");
                break;
            }
        }
    }
}

修改說明與改進要點：
- 修正與穩定化第二部份的邏輯：
  - 改用 5 位小數的四捨五入比較方式來判斷是否達到 pi=3.14159 的要求，避免直接用浮點值比較造成的不穩定性。
  - 加入最大執行次數的保護，避免在極端情況下造成無限迴圈。
- 加入標頭註解與內部註解：
  - 在檔案開頭加入檔案名稱、功能、作者與日期等註解，提升可維護性。
  - 對每段邏輯加入適當註解，說明作用與輸出格式。
- 輸出格式與字元寬度：
  - 使用 System.out.printf 的格式字串確保 i 固定位寬（6 位）且 pi 顯示小數點後 10 位，符合題意需求。
  - 使用單一空白換行的方式，並在兩部分間加入空行以區分。

改進建議（一句話）：
- 建議再加入單元測試或自動驗證，避免手動檢查輸出，同時在浮點比較處採用適當的容差與四捨五入策略，以提高穩定性與可重現性。
