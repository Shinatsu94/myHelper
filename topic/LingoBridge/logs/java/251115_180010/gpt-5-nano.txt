82

建議改進要點：可以用逐步累加的方式避免每次重新從頭計算，提高效率與可讀性。

以下為優化後的完整程式碼與修改說明。

修改說明與優化點
- 正確性與邏輯
  - 改用單一累加變數 sum（代表目前的總和），從 k=0開始逐步加入每一項，直到 i=100000；再在相同的流程下繼續累加直到 pi ≥ 3.14159，尋找最小的 i。
  - 這樣可確保與原公式一致的計算順序與精度，且更直觀地對應題意的兩個部分。
- 格式與命名
  - 使用有意義的變數名稱，如 sum（累加和）、iTerm（當前項次）等，變數命名更具可讀性。
  - 程式加入適當的註解，方便閱讀與維護。
- 備註與程式標頭
  - 增加程式檔案標題註解，說明檔案名稱、功能、作者與日期等。
- 效能
  - 透過單一循環累加，避免原程式中對每個 i 重新從頭計算的重複計算，計算量從 O(n^2) 下降到 O(n)，在本作業規模下明顯更有效。

修改後完整程式碼
/*
  檔案名稱: LeibnizPiCalculator.java
  功能說明: 使用勒貝格(Leibniz)級數近似圓周率 pi。
           (a) 輸出 i = 10000, 20000, ..., 100000 時的 pi 值，格式符合題目要求。
           (b) 找到最小的 i 使 pi = 3.14159 的區間，輸出該 i。
  作者: 電腦科系某教授
  日期: 2025-11-15
  程式內容包含適當註解與說明。
*/

public class LeibnizPiCalculator {
    public static void main(String[] args) {
        final int MAX_I = 100000;      // 對於第一部分，最大 i 值
        final int PRINT_INTERVAL = 10000; // 每隔多少項輸出一次
        double sum = 0.0;                // 累加和，使用聯立的勒貝格級數：pi/4 = 1 - 1/3 + 1/5 - 1/7 + ...

        // Part (a): 輸出 i = 10000, 20000, ..., 100000 的 pi 值
        for (int k = 0; k < MAX_I; k++) {
            // 第 k 項對應的分母為 2*k + 1，符號為 (+) 當 k 偶數，(-) 當 k 奇數
            double term = (k % 2 == 0) ? (1.0 / (2.0 * k + 1.0)) : (-1.0 / (2.0 * k + 1.0));
            sum += term;
            int termsCount = k + 1; // 此時的項數，即 i 值
            if (termsCount % PRINT_INTERVAL == 0) {
                double pi = 4.0 * sum;
                System.out.printf("i = %6d, pi = %.10f%n", termsCount, pi);
            }
        }

        // Part (b): 找到最小的 i 使 pi >= 3.14159 且 pi < 3.1416
        // 以相同的累加方式繼續計算，直到找到符合條件的 i
        int i = MAX_I; // 目前使用的 i 值（項數）
        while (true) {
            i++;
            double term = (i % 2 == 0) ? (1.0 / (2.0 * i + 1.0)) : (-1.0 / (2.0 * i + 1.0));
            sum += term;
            double pi = 4.0 * sum;
            if (pi >= 3.14159 && pi < 3.1416) {
                // 為符合題意的區間，先輸出一個空行再輸出結果
                System.out.println();
                System.out.printf("i = %6d%n", i);
                break;
            }
        }
    }
}
