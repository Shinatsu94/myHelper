6

- 正確性: 0/50
- 邏輯: 0/30
- 格式: 6/10
- 備註: 0/10

以下為改進後的完整程式碼與說明

修改說明與重點
- 重新實作題目需求：改用勒布尼茨公式計算 pi，依序輸出 i=10000, 20000, ..., 100000 對應的 pi，且 pi 顯示到小數點後10位，i 顯示到6位數對齊；同時找出使 pi 四捨五入到小數點後五位等於 3.14159 的最小 i，並輸出該 i。
- 將原本的無關輸入與判斷移除，改為逐步累加的方式計算 pi，並以格式化輸出確保輸出符合題目要求。
- 加入適當的檔案標頭註解，並採用有意義的變數命名與良好縮排。

完整程式碼（Java）
```java
/*
File: LeibnizPi.java
Description: 使用勒布尼茨公式計算 pi 的近似值，輸出指定格式；同時找出使 pi 四捨五入到小數點後五位等於 3.14159 的最小 i。
Author: 教授
Date: 2025-11-12
*/

public class LeibnizPi {
    public static void main(String[] args) {
        double sum = 0.0;

        // 題目部分 (a): i = 10000, 20000, ..., 100000
        for (int i = 1; i <= 100000; i++) {
            double term = ((i % 2 == 1) ? 1.0 : -1.0) / (2.0 * i - 1.0);
            sum += term;
            if (i % 10000 == 0) {
                double pi = sum * 4.0;
                System.out.println(String.format("i = %6d, pi = %.10f", i, pi));
            }
        }

        // 題目部分 (b): 找出使 pi 四捨五入到小數點後五位為 3.14159 的最小 i
        int iMin = -1;
        double targetRounded = 314159.0; // 3.14159 * 100000
        // 已計算到 i = 100000，繼續累加直到找到符合條件的 i
        for (int i = 100001; i <= 2000000; i++) {
            double term = ((i % 2 == 1) ? 1.0 : -1.0) / (2.0 * i - 1.0);
            sum += term;
            double pi = sum * 4.0;
            if (Math.round(pi * 100000.0) == targetRounded) {
                iMin = i;
                break;
            }
        }
        System.out.println(String.format("i = %6d", iMin));
    }
}
```

修改部分的原因
- 將原先與題目無關的輸入與判斷移除，改以正確的數值方法計算 pi，符合題目需求與正確性評分標準。
- 使用逐次累加的方式計算，能有效追蹤每個 i 的 pi 值，並以格式化輸出確保符合指定輸出格式與精度。
- 加入檔案標頭註解與有意義的命名，提升可讀性與維護性。

改進建議或反饋（一句話）
- 建議在實作前先確認題意需求與輸出格式，並以自動化的格式輸出與穩定的近似精度作為評估點，以避免分數因格式或細節不符而受影響。
