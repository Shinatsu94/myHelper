4

評分說明（依您的標準逐項評分，以下僅為本次作業的判分示例，實際分數可依您的評分細則微調）：
- 正確性：0/50
  - 學生的排序邏輯嚴重錯誤，最後輸出與題目要求嚴重不符（原始程式會覆蓋元素，且最後一個元素被設定為 -1，且未完成正確的排序與輸出格式）。
- 邏輯：0/30
  - 嘗試使用選擇排序的概念，但實作錯誤：錯把最大值/最小值的邏輯混亂、未正確交換、未維護陣列內容的一致性，導致結果錯誤。
- 格式：4/10
  - 變數命名較為簡略（ary、max），缺乏註解與程式標頭說明；整體縮排尚可，結構基本清楚，但未有清楚的註解與說明。
- 備註：0/10
  - 未提供檔案名稱、功能說明、作者、日期等標頭註解與適當的程式內容註解。

總分：4

修改與優化後的完整程式碼（已符合題意，支援負數、一次執行完成、並提供清楚註解與標頭）：
/**
 * 檔案名稱: SortArrayAscending.java
 * 功能: 將使用者輸入的一維整數陣列進行升序排序，並輸出結果
 * 作者: 你可以填寫
 * 日期: 2025-11-12
 * 版本: 1.0
 * 註解: 讀取陣列長度與元素；採用選擇排序，適用任意長度與含負數的情況；輸出以空格分隔，結尾不額外空白。
 */
import java.util.Scanner;

public class SortArrayAscending {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        // 讀取陣列長度
        int n = 0;
        if (sc.hasNextInt()) {
            n = sc.nextInt();
        }

        int[] ary = new int[n];
        // 依序讀取陣列元素
        for (int i = 0; i < n; i++) {
            if (sc.hasNextInt()) {
                ary[i] = sc.nextInt();
            } else {
                ary[i] = 0; // 若輸入不足，補上預設值0，確保程式穩定
            }
        }
        sc.close();

        // 選擇排序：由小到大
        for (int i = 0; i < n - 1; i++) {
            int minIdx = i;
            for (int j = i + 1; j < n; j++) {
                if (ary[j] < ary[minIdx]) {
                    minIdx = j;
                }
            }
            // 交換 ary[i] 與 ary[minIdx]
            int tmp = ary[i];
            ary[i] = ary[minIdx];
            ary[minIdx] = tmp;
        }

        // 輸出排序後的陣列，元素之間以單一空格分隔
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < n; i++) {
            if (i > 0) sb.append(' ');
            sb.append(ary[i]);
        }
        System.out.print(sb.toString());
    }
}

修改說明與原因：
- 修正排序邏輯：改為正確的選擇排序，找到子陣列中最小值的索引並與目前位子交換，避免覆蓋原值、產生錯誤資料與不正確的輸出。
- 移除原程式中不合理的 -1 設定：原程式最後把最後一個元素設為 -1，這破壞了排序後的資料，且與題意不符。
- 增加程式標頭與適當註解：提供檔案名稱、功能、日期等資訊，並在關鍵區塊加上註解，提升可讀性與維護性。
- 強化輸入穩定性：使用 hasNextInt 檢查與回補缺失輸入，避免未預期的例外或不穩定行為。
- 輸出格式控制：以單一空格分隔輸出，不在結尾附加多餘空白。

改進建議（一句話）：
- 當可接受時，直接使用 Arrays.sort(ary) 以簡化程式與提升效率，並保留必要的輸入檢核與輸出格式控制以符合測資需求。

附註：
- 若你想保留手寫排序的教學價值，選擇排序是一個清晰且穩定的實作；若追求更高效能，Arrays.sort 能提供更佳的時間複雜度與實作穩定性。
