0

修改後程式碼：
/**
 * 程式名稱 : Leibniz Pi 計算
 * 功能說明：使用萊布尼茲級數計算 pi，輸出 i = 10000, 20000, ..., 100000 對應的 pi 值，格式為 i6位數與 pi的小數點後10位；再輸出使 pi 四捨五入至小數點後5位等於 3.14159 的最小 i。
 * 日期: 2025/11/12
 * 作者: 教師
 * 說明: 原作業為「數字顛倒」與題目無關，經重構以符合題目需求。
 */

public class LeibnizPiCalculator {
    public static void main(String[] args) {
        // 部分(a)：計算 pi 值，輸出 i = 10000, 20000, ..., 100000
        double sum = 0.0;
        int maxI = 100000;
        int step = 10000;
        for (int i = 1; i <= maxI; i++) {
            int denom = 2 * (i - 1) + 1;
            double term = (((i - 1) & 1) == 0) ? (1.0 / denom) : (-1.0 / denom);
            sum += term;
            if (i % step == 0) {
                double pi = 4.0 * sum;
                System.out.printf("i = %6d, pi = %.10f%n", i, pi);
            }
        }

        // 空一行分隔兩部分
        System.out.println();

        // 部分(b)：找出使 pi 四舍五入到小數點後5位為 3.14159 的最小 i
        double sumTarget = 0.0;
        int iTarget = -1;
        // 目標四捨五入到 5 位小數的整數表示
        final long targetRounded = 314159L;
        // 設定一個合理的上限以確保能找到答案
        int upperLimit = 2000000;
        for (int i = 1; i <= upperLimit; i++) {
            int denom = 2 * (i - 1) + 1;
            double term = (((i - 1) & 1) == 0) ? (1.0 / denom) : (-1.0 / denom);
            sumTarget += term;
            double piVal = 4.0 * sumTarget;
            if (Math.round(piVal * 1e5) == targetRounded) {
                iTarget = i;
                break;
            }
        }

        // 輸出最小 i
        System.out.printf("i = %6d%n", iTarget);
    }
}

修改說明：
- 將原本與題目無關的數字顛倒程式完全移除，改為實作與題意對應的萊布尼茲級數計算。
- 以逐步累加的方式計算 pi，避免重複計算，提升運算效率與穩定性；變數命名改為更具語意的 sum、sumTarget。
- 輸出格式改為使用格式化輸出，符合題目要求的 i 為六位寬、pi 為小數點後十位，並在中間插入空行分隔兩大區塊。
- 新增完整註解，包含檔案功能說明、輸出邏輯、以及兩部分的輸出順序，提升可讀性與維護性。

改進建議或反饋（一句話）：
可考慮使用高精度演算法或加速技巧（例如 Kahan 求和法）以減少浮點誤差，並在大規模累加時提升穩定性與效率。
