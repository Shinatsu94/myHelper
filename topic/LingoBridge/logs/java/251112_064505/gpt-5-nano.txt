4

以下根據您的評分標準對學生原始程式進行評分與改寫說明。

評分與說明
- 正確性（50%）：0/50
  - 原程式無法解題，只是做數字反轉，與題目要求的 Leiiniz 公式計算與輸出需求無關。
- 邏輯（30%）：0/30
  - 原程式邏輯與題意嚴重不符，未涉及 pi 計算、輸出格式與變數命名等。
- 格式（10%）：4/10
  - 程式基本結構正確、語法無誤，命名不具語意且缺乏註解與標頭，整體可讀性尚可提升。
- 備註（10%）：0/10
  - 無程式標頭註解與說明。
總分：4/100

修改方案與原因
- 重新實作題目需求的核心演算法：使用 Leibniz 公式 pi = 4 sum_{k=0}^{i-1} (-1)^k /(2k+1)。
- (a) 對 i = 10000, 20000, ..., 100000 逐次計算並輸出，格式符合要求：i 以六位寬度右對齊，pi 保留小數點後 10 位，且輸出格式為 "i = %6d, pi = %.10f"。
- (b) 以累積方式逐步增加項數，找出最小的 i，使 pi 四捨五入到小數點後第五位等於 3.14159，並輸出該 i；遍歷過程使用逐次累積以避免過度重複計算，提升效能。
- 增加程式標頭註解與適當內部註解，並使用 Locale.US 以確保小數點符號在不同區域設定下皆為 " . "。
- 程式命名與結構做改善，變數命名更具語意，整體可讀性提升。

修改後完整程式碼
```java
import java.util.Locale;

/**
 * File: LeibnizPi.java
 * 功能: 使用 Leibniz 公式近似圓周率 π
 *       (a) 輸出 i = 10000, 20000, ..., 100000 對應的 pi 值，格式符合題目要求
 *       (b) 找出最小的 i，使 pi 四捨五入到小數點後第五位為 3.14159
 * 作者: 課堂實作
 * 日期: 2025-11-11
 */
public class LeibnizPi {
    public static void main(String[] args) {
        // (a) 輸出 i = 10000, 20000, ..., 100000 的 pi 值
        for (int i = 10000; i <= 100000; i += 10000) {
            double pi = leibnizPi(i);
            // i 以六位寬度顯示，pi 保留小數點後10位
            System.out.printf(Locale.US, "i = %6d, pi = %.10f%n", i, pi);
        }

        // (b) 找出最小的 i，使 pi 四捨五入到五位小數等於 3.14159
        double target = 3.14159;
        double sum = 0.0;
        int i = 0;
        while (true) {
            // 加上第 i+1 項
            double term = ( (i % 2) == 0 ? 1.0/(2*(i) + 1) : -1.0/(2*(i) + 1) );
            sum += term;
            i++;
            double pi = 4.0 * sum;
            long rounded = Math.round(pi * 100000.0); // 五位小數四捨五入的整數表示
            if (rounded == Math.round(target * 100000.0)) {
                System.out.println("i = " + i);
                break;
            }
            // 安全保護，避免無窮迴圈
            if (i > 2000000) {
                System.out.println("i = " + i);
                break;
            }
        }
    }

    // 計算前 terms 個項的 pi/4 值
    private static double leibnizPi(int terms) {
        double sum = 0.0;
        for (int k = 0; k < terms; k++) {
            double term = 1.0 / (2 * k + 1);
            sum += (k % 2 == 0) ? term : -term;
        }
        return 4.0 * sum;
    }
}
```

修改說明要點
- 變更點1：用 Leiniz 公式計算 pi，替代原先的無關邏輯，符合題意。
- 變更點2：輸出格式採用 System.out.printf，確保 i 為六位寬度且 pi 為十位小數，且使用 Locale.US 以避免 locale 影響小數點符號。
- 變更點3：對 (b) 的部分採用累積方式逐步增加項數，避免重複重新計算整個序列，提升效能並確保在合理時間內找到最小 i。
- 變更點4：加入標頭註解與內部註解，提升可讀性與維護性。

一語建議
- 建議在正式上課評分中，提供清晰的輸出格式與邏輯評分規準，並鼓勵學生在提交前先自我驗證輸出格式與邏輯正確性，以提升作業品質。

如果需要，我可以再提供不同語言版本的實作或增加更多測試用例幫助學生自我驗證。
