我是一名資訊工程系的教授，主要教授「Java程式設計」，
我會提供給你一份作業題目以及學生所提交的作業，請根據我的標準進行批改作業，並使用中文回答。

我的標準(標示出每一項的個別分數):
- 正確性(50%)：程式是否產生正確的結果
- 邏輯(30%)：程式是否以簡單、合理、以及正確的邏輯作答問題
- 格式(10%)：程式碼是否保持適當的縮排、變數是否以有意義名稱命名
- 備註(10%)：程式標頭註解說明該程式檔案名稱、功能、作者、日期，程式內容有適當註解說明

要求:
1. 根據我的標準為這份作業打分（0-100），並將總分在第一行獨立列出
2. 將程式碼進行優化，並展示修改後完整程式碼，以及說明修改該部分的原因
3. 用一句話說明改進建議或反饋


題目：
【題目】
建立一個任意長度的一維陣列，將陣列內容進行升幕排序 (由小至大)，
讓使用者先輸入陣列的長度。
接著，讓使用者依序輸入陣列中的每個整數。
最後印出排序後的陣列內容。

備註:
- 請勿使用EOF，執行一次程式後結束程序，避免無法通過測資。
- 輸入元素包含負數，請留意是否支援。

【input】
5
8 3 12 5 1

【output】
1 3 5 8 12

學生作答程式：
import java.util.Scanner;
import java.util.Locale;

public class MatrixInverse {

    /**
     * 计算 3x3 矩阵的逆矩阵。
     * @param matrix 3x3 的输入矩阵
     * @return 3x3 的逆矩阵
     */
    public static double[][] inverse(double[][] matrix) {
        // 确保输入是 3x3 矩阵
        if (matrix.length != 3 || matrix[0].length != 3) {
            throw new IllegalArgumentException("矩阵必须是 3x3 格式");
        }

        // 1. 计算行列式 (Determinant)
        double det = matrix[0][0] * (matrix[1][1] * matrix[2][2] - matrix[1][2] * matrix[2][1])
                   - matrix[0][1] * (matrix[1][0] * matrix[2][2] - matrix[1][2] * matrix[2][0])
                   + matrix[0][2] * (matrix[1][0] * matrix[2][1] - matrix[1][1] * matrix[2][0]);

        // 如果行列式为零，则矩阵不可逆 (在实际题目中通常不会遇到，但保险起见)
        if (Math.abs(det) < 1e-9) { // 使用一个小的阈值来判断是否接近于零
            // 实际上，如果题目保证输入是可逆的，这行代码可以省略或简化。
            // 但为了健壮性，我们可以返回一个表示错误或不可逆的值。
            // 在本例中，我们假设所有测试输入都是可逆的。
            // 如果遇到不可逆矩阵，逆矩阵的计算会涉及除以零，导致错误。
            // 由于题目没有明确说明不可逆的情况，我们假设输入均可逆。
            // 为了遵循题目要求的输出格式，我们继续，但需要注意这种情况。
            // 如果在实际运行中遇到不可逆的情况，程序可能会输出不合理的结果或异常。
        }

        // 行列式的倒数
        double invDet = 1.0 / det;

        // 2. 计算伴随矩阵 (Adjugate Matrix)
        double[][] adjugate = new double[3][3];

        // 伴随矩阵是代数余子式矩阵的转置
        // C[i][j] = (-1)^(i+j) * M[i][j] (M是余子式)

        // a11, a12, a13
        adjugate[0][0] =  (matrix[1][1] * matrix[2][2] - matrix[1][2] * matrix[2][1]);
        adjugate[0][1] = -(matrix[0][1] * matrix[2][2] - matrix[0][2] * matrix[2][1]); // 注意 (-1)^(1+2) = -1
        adjugate[0][2] =  (matrix[0][1] * matrix[1][2] - matrix[0][2] * matrix[1][1]);

        // a21, a22, a23
        adjugate[1][0] = -(matrix[1][0] * matrix[2][2] - matrix[1][2] * matrix[2][0]); // 注意 (-1)^(2+1) = -1
        adjugate[1][1] =  (matrix[0][0] * matrix[2][2] - matrix[0][2] * matrix[2][0]);
        adjugate[1][2] = -(matrix[0][0] * matrix[1][2] - matrix[0][2] * matrix[1][0]); // 注意 (-1)^(2+3) = -1

        // a31, a32, a33
        adjugate[2][0] =  (matrix[1][0] * matrix[2][1] - matrix[1][1] * matrix[2][0]);
        adjugate[2][1] = -(matrix[0][0] * matrix[2][1] - matrix[0][1] * matrix[2][0]); // 注意 (-1)^(3+2) = -1
        adjugate[2][2] =  (matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0]);

        // 3. 计算逆矩阵 A^-1 = (1/det) * adj(A)
        double[][] inverseMatrix = new double[3][3];
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                inverseMatrix[i][j] = adjugate[i][j] * invDet;
            }
        }

        return inverseMatrix;
    }

    /**
     * 格式化输出矩阵。
     * @param matrix 要输出的矩阵
     */
    public static void printMatrix(double[][] matrix) {
        // 使用一个小的常数来判断是否接近于零
        final double EPSILON = 1e-9; 

        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                double value = matrix[i][j];

                String output;
                // 判断元素是否接近于零
                if (Math.abs(value) < EPSILON) {
                    // 如果元素为零，直接打印 '0'
                    output = "0";
                } else {
                    // 否则，打印小数点后四位
                    // %.4f 表示保留四位小数
                    output = String.format(Locale.US, "%.4f", value);
                }

                // 元素之间使用空格 ' ' 进行分隔
                if (j < 2) {
                    System.out.print(output + " ");
                } else {
                    // 每行最后一个元素后面不加空格
                    System.out.print(output);
                }
            }
            
            // 打印换行，除了最后一行
            if (i < 2) {
                System.out.println(); // 相当于 '\n'
            }
        }
        // 注意：根据题目要求“最后一行不得有空白符号”，所以最后一行打印后不应有额外的换行符。
        // 因为 System.out.print(output); 后没有再加 System.out.println()，所以符合要求。
    }

    public static void main(String[] args) {
        // 设置默认的 Locale 为 US，确保浮点数的小数点是 '.'
        Scanner scanner = new Scanner(System.in);
        scanner.useLocale(Locale.US);

        double[][] inputMatrix = new double[3][3];

        // 读取 3x3 矩阵
        // 注意：由于题目没有明确要求处理多个输入，我们只处理一个 3x3 矩阵。
        // 如果需要处理多个，需要将读取和计算逻辑放入循环中。
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                if (scanner.hasNextDouble()) {
                    inputMatrix[i][j] = scanner.nextDouble();
                } else {
                    // 处理输入不足或类型不匹配的情况
                    System.err.println("输入格式错误或数据不足。");
                    return;
                }
            }
        }
        
        // 检查输入后是否还有额外的 token，并跳过可能的换行符或空格
        if (scanner.hasNextLine()) {
             scanner.nextLine(); // 消费掉可能剩下的换行符
        }
        scanner.close(); // 关闭 Scanner

        try {
            // 计算逆矩阵
            double[][] resultMatrix = inverse(inputMatrix);

            // 格式化输出
            printMatrix(resultMatrix);
        } catch (IllegalArgumentException e) {
            System.err.println("错误: " + e.getMessage());
        } catch (ArithmeticException e) {
            // 这可能在行列式为零（或接近零）时发生
            System.err.println("错误: 矩阵不可逆或计算中发生除以零。");
        }
    }
}
