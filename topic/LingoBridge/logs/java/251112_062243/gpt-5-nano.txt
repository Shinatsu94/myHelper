2

作業評分
- 正確性: 0/50
- 邏輯: 0/30
- 格式: 2/10
- 備註: 0/10
總分: 2/100

修改說明與優化要點
- 以題目要求改寫成真正計算與輸出的程式，取代原始提交的無關功能（反轉整數）。
- 使用 Leibniz 公式逐步累加求 pi：pi ≈ 4 * sum_{k=0}^{i-1} (-1)^k / (2k+1)，並以增量方式計算提升效率。
- 先輸出 i=10000, 20000, ..., 100000 時的 pi，格式符合題意：i 使用寬度6對齊，pi 小數點後10位，並以單一空格分隔。
- 輸出完前段後，繼續累加直到 pi >= 3.14159，輸出該最小 i 值（格式同樣對齊）並留一空行作區隔。
- 移除不必要的 Scanner 與輸入處理，改用常數與程式邏輯自動產出結果，提升可重用性與可讀性。
- 加入完整的檔案標頭註解與適當的程式內容註解，改善格式與可維護性。

修改後完整程式碼（已優化並符合題目輸出格式）
/*
Filename: LeibnizPi.java
功能: 計算使用 Leibniz 公式近似的 pi，列印 i = 10000, 20000, ..., 100000 的 pi 值，並輸出達到 pi >= 3.14159 的最小 i。
作者: 請填寫
日期: 2025-11-11
*/

public class LeibnizPi {
    public static void main(String[] args) {
        // 使用 Leibniz 公式近似 pi: pi ≈ 4 * sum_{k=0}^{i-1} (-1)^k / (2k+1)
        double sum = 0.0;

        // 輸出 i = 10000, 20000, ..., 100000 的 pi 值
        for (int k = 0; k < 100000; k++) {
            double term = ((k % 2 == 0) ? 1.0 : -1.0) / (2.0 * k + 1.0);
            sum += term;
            int iValue = k + 1; // terms count
            if (iValue % 10000 == 0) {
                double pi = 4.0 * sum;
                System.out.println("i = " + String.format("%6d", iValue) + ", pi = " + String.format("%.10f", pi));
            }
        }

        // 找出最小的 i 使 pi >= 3.14159
        int iIndex = 100000;
        while (4.0 * sum < 3.14159) {
            double term = ((iIndex % 2 == 0) ? 1.0 : -1.0) / (2.0 * iIndex + 1.0);
            sum += term;
            iIndex++;
        }

        // 輸出區隔與結果
        System.out.println();
        System.out.println("i = " + String.format("%6d", iIndex));
    }
}

修改原因說明
- 將原本無關的反轉整數程式改為正確的 pi 近似計算，符合題意的輸出格式與精度要求。
- 透過逐步累加提升計算效率，避免每次都重新從頭計算，尤其對於需要計算到高 i 的情況。
- 以格式化字串實現 i 與 pi 的對齊輸出，滿足「i顯示到6位數、pi顯示到小數點後10位、每行以單一空白區隔」的要求。
- 增加程式標頭與內部註解，提升可讀性與後續維護性。

改進建議或反饋（一句話）
建議在正式提交前，將輸出格式與邏輯邊界（如 pi 精度與區間終點）寫成可配置常數，提升可讀性與重用性。
