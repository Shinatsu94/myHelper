4

作業評分與說明
- 正確性 (50%): 0/50
  - 原程式與題目需求無關，僅判斷數字位數順序，與 pi 計算與輸出格式無關，未達題目要求。
- 邏輯 (30%): 0/30
  - 邏輯用途為判斷三個位數是否單調遞增，與本題的連分式求 pi 無關，未涵蓋 (a) 與 (b) 的計算與判斷。
- 格式 (10%): 4/10
  - 程式有適度的縮排與可讀性，但命名不具語意，且缺乏符合題意的註解與標頭。
- 備註 (10%): 0/10
  - 無程式檔頭註解與說明。

修改說明與改進後作業內容
以下提供一份符合題意的改進版本，包含：
- 正確實作 Leibniz 公式求 pi。
- (a) 輸出 i = 10000, 20000, ..., 100000 與對應的 pi，pi 保留小數點後10位，i 顯示為寬度6以對齊。
- (b) 找出使 pi=3.14159 的最小 i，並輸出該 i，寬度同樣為6。
- 程式含標頭註解，變數命名具意義，並避免不需要的輸入。
- 程式碼經過格式化與註解說明，易於閱讀與維護。

修改後完整程式碼（Java）

/*
 * File: LeibnizPiCalculator.java
 * 功能: 計算 pi 使用 Leibniz 公式，輸出
 *       (a) i 為 10000, 20000, ..., 100000 時的 pi 值 (小數點後10位)
 *       (b) 最小的 i 使 pi 的近似值等於 3.14159，並輸出該 i（6 位寬度顯示）
 * 作者: 你可以填你的姓名
 * 日期: 2025-11-12
 */

public class LeibnizPiCalculator {
    public static void main(String[] args) {
        // Part (a): 逐步計算直到指定的 i 值，輸出對應的 pi 值
        for (int i = 10000; i <= 100000; i += 10000) {
            double sum = 0.0;
            for (int k = 0; k < i; k++) {
                // 梯度項的符號依 k 的偶奇性交替
                double term = 4.0 * (((k & 1) == 0) ? 1.0 : -1.0) / (2.0 * k + 1.0);
                sum += term;
            }
            System.out.printf("i = %6d, pi = %.10f%n", i, sum);
        }

        // Part (b): 找到最小的 i 使 pi 的近似等於 3.14159（以五位小數四捨五入後比較）
        double s = 0.0;
        int k = 0;
        final double TARGET = 3.14159;
        int minimalIForTarget = 0;

        while (true) {
            double term = 4.0 * (((k & 1) == 0) ? 1.0 : -1.0) / (2.0 * k + 1.0);
            s += term;

            // 將當前近似值四捨五入到小數點後5位，與 TARGET 比較
            double roundedTo5 = Math.round(s * 1e5) / 1e5;
            if (roundedTo5 == TARGET) {
                minimalIForTarget = k + 1; // i = k+1
                break;
            }
            k++;
        }

        System.out.printf("i = %6d%n", minimalIForTarget);
    }
}

修改部分的修改理由
- 重新以題意為核心實作：改用 Leibniz 公式逐項累加，輸出指定的 i 值對應的 pi，以及找出最小的 i 使 pi 約等於 3.14159。
- 輸出格式與精度：遵循題目要求，i 使用寬度6輸出以對齊，pi 輸出到小數點後10位；使用 System.out.printf 以確保格式穩定。
- 結構與可維護性：加入程式標頭與註解、使用具語意的變數命名、移除多餘輸入等，讓程式更易閱讀與維護。

改進建議（一句話）
在實作題目時，先確定輸出格式與精度要求，再以正確的數值演算法實作並附上清晰的註解與程式標頭，避免混用與題意無關的邏輯。

若需要，我也可以再提供一個可選的版本，採用一次性計算而非兩段式獨立計算，或是加上效能改良與錯誤處理。
