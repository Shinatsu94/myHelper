8
以下為依照題目需求所給的程式批改與修正說明。

學生原程式與評分
- 正確性(50%): 0/50
  - 程式與題目要求嚴重不符，未計算 pi 值或輸出指定的 i、pi 組合。
- 邏輯(30%): 0/30
  - 題意為計算 Leibniz 公式的近似並輸出指定格式，但程式與邏輯皆不符合需求。
- 格式(10%): 8/10
  - 程式結構清晰、變數命名有意義，縮排規範，具可讀性；但缺乏程式標頭與註解，且與作業題意不符。
- 備註(10%): 0/10
  - 缺少檔案標頭註解、說明、作者與日期等。

總結與建議
- 本次以不符題意為主，因此總分定為 8（取整到最近整數的作法）。建議採用下方修正版以正確解法完成作業。

修正後完整程式碼
/*
 檔案名稱: LeibnizPi.java
 功能說明: 使用 Leiniz 近似計算 pi，輸出 i 為 10000, 20000, ..., 100000 時的 pi 值；並找出最小使 pi 類近成 3.14159 的 i 值 (近似誤差小於 0.000005)。
 作者: [你的名字]
 日期: 2025-11-11
 版本: 1.0
 內容說明: 採用單次迴圈累加方式，逐步累加 1/(2k+1) 的符號，提升執行效率，並依輸出格式要求輸出。
*/
import java.util.Locale;

public class LeibnizPi {
    public static void main(String[] args) {
        // 設定 locale 以確保小數點格式穩定
        Locale.setDefault(Locale.US);

        int maxI = 100000;
        double sum = 0.0;

        // 逐步累加，當 k+1 等於 10000、20000、...、100000 時輸出 pi
        for (int k = 0; k < maxI; k++) {
            double term = ((k % 2 == 0) ? 1.0 : -1.0) / (2.0 * k + 1.0);
            sum += term;

            if ((k + 1) % 10000 == 0) {
                int iVal = k + 1;
                double piApprox = 4.0 * sum;
                System.out.print("i = ");
                // 這裡使用 width 6 的格式化，保留單個空白在「i = 」之後
                System.out.printf("%6d, pi = %.10f%n", iVal, piApprox);
            }
        }

        // 找出最小的 i，使 pi 的近似值與 3.14159 的差距小於等於 0.000005
        double target = 3.14159;
        double sumForMinI = 0.0;
        int minI = -1;
        for (int k = 0; k < 2000000; k++) {
            double term = ((k % 2 == 0) ? 1.0 : -1.0) / (2.0 * k + 1.0);
            sumForMinI += term;
            double piApprox = 4.0 * sumForMinI;
            if (Math.abs(piApprox - target) <= 0.000005) {
                minI = k + 1;
                break;
            }
        }

        // 輸出最小 i 的結果（與題意「i = 136121」的示例相符的格式）
        if (minI != -1) {
            System.out.print("i = ");
            System.out.printf("%d%n", minI);
        } else {
            // 若未找到，給出提示
            System.out.println("i = 未找到符合條件的最小 i");
        }
    }
}

修改說明與原因
- 重新實作成符合題意的 Leiniz 公式求 pi：原程式與題目無關，未對 pi 進行計算與輸出。本修正以 Lehiz 公式為核心，計算 pi 值。
- 單次累加提升效率：使用單一迴圈逐步累加，當 i 達到 10000、20000、...、100000 時再輸出，避免多次重新計算。
- 輸出格式與對齊：使用 System.out.print 與 System.out.printf 進行對齊輸出，i 使用寬度為 6 的格式，pi 使用小數點後 10 位，符合題目要求。
- 增加檔頭註解與說明：加入標頭註解，說明檔案名稱、功能、作者、日期與基本說明，提升可維護性與可讀性。
- 新增最小 i 設定：為滿足題目 (b) 的需求，計算出最小的 i 以使 pi 約略接近 3.14159，輸出該 i。若找不到再給出相應提示。

一句話改進建議
- 從一開始就以正確的數學模型實作並添加完整的輸出格式與註解，避免偏離題意的實作造成分數損失與重構成本。
