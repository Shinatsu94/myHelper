6

- 正確性: 0/50
- 邏輯: 0/30
- 格式: 6/10
- 備註: 0/10

修改後的作業說明與程式

說明與評語
- 原程式與題意嚴重不符，僅做「判定數字是否遞增」的測試，與題目要求的「計算勒布尼茲級數近似值並輸出指定格式」毫無關聯，故正確性與邏輯分皆為0。
- 新版程式以勒布尼茲級數逐步累加的方式計算 pi，並符合題意的輸出格式與需求：
  - (a) 依序輸出 i=10000,20000,...,100000 對應的 pi，pi 以小數點後十位輸出，i 以六位寬度輸出。
  - (b) 找出最小的 i，使 pi 的五位小數等於 3.14159，輸出該 i（同樣以六位寬度顯示）。
- 重要修改點：
  - 使用逐步累加而非重新計算整個和以提升效能。
  - 對輸出格式做嚴格控制，符合「i 显示到6位數、pi 顯示到小數點後10位」的要求。
  - 增加註解與清楚的程式名稱，方便維護。

修改後完整程式碼（已改為符合題意的實作）

import java.util.*;

public class LeibnizPiDemo {
    public static void main(String[] args) {
        // Part (a): 使用 i 個項計算 pi，輸出 i=10000,20000,...,100000 對應的 pi
        int maxI = 100000;
        double sum = 0.0; // sum 為 sum_{k=1..i} (-1)^{k+1} / (2k-1)
        StringBuilder partA = new StringBuilder();
        for (int i = 1; i <= maxI; i++) {
            sum += ((i & 1) == 1 ? 1.0 : -1.0) / (2.0 * i - 1.0);
            if (i % 10000 == 0) {
                double pi = 4.0 * sum;
                partA.append(String.format("i = %6d, pi = %.10f%n", i, pi));
            }
        }

        // Part (b): 找出使 pi 最接近 3.14159 的最小 i（四捨五入成 3.14159）
        int minI = -1;
        // 繼續累加，從 i=1 開始以避免額外複雜度
        sum = 0.0;
        int maxI2 = 2000000; // 適度上限，根據題意示例大約在 1.36e5
        for (int i = 1; i <= maxI2; i++) {
            sum += ((i & 1) == 1 ? 1.0 : -1.0) / (2.0 * i - 1.0);
            double piVal = 4.0 * sum;
            if (String.format("%.5f", piVal).equals("3.14159")) {
                minI = i;
                break;
            }
        }

        // 輸出結果
        System.out.print(partA.toString());
        if (minI != -1) {
            System.out.println("i = " + String.format("%6d", minI));
        } else {
            System.out.println("i = NotFound");
        }
    }
}

修改部分的原因說明
- 使用逐步累加而非每次都從頭計算，能大幅降低時間複雜度，適合處理上萬至上百萬的 i。
- 針對輸出需求，加入 i 的寬度格式化與 pi 的小數位數控制，確保符合題目格式要求。
- 增加一段自動尋找最小 i 使 pi 的五位小數為 3.14159 的邏輯，滿足題目 (b) 的需求。
- 程式增加清楚的名稱與結構，便於日後維護與擴充。

改進建議（一句話）
- 建議先完整理解題意並以逐步累加的方式實作，並嚴格對齊輸出格式與註解，提升可讀性與效能。
