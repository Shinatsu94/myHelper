2

評分與建議說明
- 正確性(50%): 0/50
  - 學生的程式與題目需求不符，僅判斷「是否為整數位階序」的功能，與計算 pi 的題意無關，因此正確性得分為 0。
- 邏輯(30%): 0/30
  - 作業核心在於用 Lehmann/Lieibniz 公式計算 pi 的近似並依題目輸出特定格式；學生程式沒有解題邏輯，屬於錯誤方向。
- 格式(10%): 2/10
  - 程式碼有基本縮排，但變數命名過於單一（如 a、b、n、m、c、b），不利於閱讀與維護；缺少清晰的程式結構與註解。
- 備註(10%): 0/10
  - 程式缺乏標頭註解（檔案名稱、功能、作者、日期等），不符合編寫規範。

修改後的完整程式碼與說明
以下提供一份符合題意的 Java 程式，會：
- 計算 pi 的近似值，使用官方給定的公式 4(1 - 1/3 + 1/5 - 1/7 + … + (-1)^(i-1)/(2i-1))，i 由 10000 到 100000，步長 10000。
- 輸出格式符合要求，i 以六位數寬度對齊，pi 保留小數點後十位。
- 輸出完第一段後，空行，再輸出最小的 i，使得 pi 四捨五入到小數點後五位為 3.14159。

可直接複製並存成 PiLeibniz.java：

/*
檔案名稱: PiLeibniz.java
功能: 使用 Leibniz 公式計算 pi 的近似值，輸出 i = 10000…100000 之 pi 值，然後找出使 pi 四捨五入到小數點後五位為 3.14159 的最小 i。
作者: 你的名字
日期: 2025-11-11
說明: 內含適當註解與格式化輸出。
*/

public class PiLeibniz {
    public static void main(String[] args) {
        // 第一部分：輸出 i = 10000, 20000, ..., 100000 的 pi 近似值
        int[] thresholds = {10000, 20000, 30000, 40000, 50000,
                            60000, 70000, 80000, 90000, 100000};
        double sum = 0.0;
        int idx = 0;

        // 逐步累加直到 max(thresholds)
        int maxI = thresholds[thresholds.length - 1];
        for (int i = 1; i <= maxI; i++) {
            double term = 1.0 / (2.0 * i - 1.0);
            if ((i & 1) == 1) { // i 為奇數，加 term
                sum += term;
            } else {            // i 為偶數，減 term
                sum -= term;
            }

            if (i == thresholds[idx]) {
                double pi = 4.0 * sum;
                System.out.printf("i = %6d, pi = %.10f%n", i, pi);
                idx++;
                if (idx >= thresholds.length) break;
            }
        }

        // 第二部分：找出最小的 i 使 pi 四捨五入成 3.14159（小數點後5位）
        System.out.println(); // 空行分隔
        sum = 0.0;
        int minimalI = -1;
        // 由 1 開始遞增，找到符合條件的最小 i
        for (int i = 1; i <= 2000000; i++) { // 上限設定較大以避免無限迴圈
            double term = 1.0 / (2.0 * i - 1.0);
            if ((i & 1) == 1) sum += term;
            else sum -= term;
            double pi = 4.0 * sum;
            // 四捨五入到小數點後5位
            String rounded = String.format("%.5f", pi);
            if ("3.14159".equals(rounded)) {
                minimalI = i;
                break;
            }
        }
        System.out.println("i = " + minimalI);
    }
}

修改原因與重點
- 重新實作題意：原學生程式與題目無關，需以對題目的正確算術計算為核心。
- 使用累計方式提升效能：透過單一循環累積前面的和，避免每次都從頭計算，提升效率。
- 輸出格式與精度控制：使用 System.out.printf 來嚴格控制輸出格式，確保 i 為六位寬度、pi 保留十位小數，並在結尾補上空行與最小 i 的輸出。
- 程式命名與註解：提供適當的檔案註解與程式內註解，改善可讀性與可維護性。

改進建議或反饋（一句話）
- 建議在撰寫數值計算作業時，先設計清楚的輸出格式與邊界條件，並以單一遍歷或動態累加方式實作，以提升閱讀性與執行效率；同時務必把與題意無關的測試思路排除，以符合作業需求。

如需我調整輸出格式或輸出內容的順序，告訴我你的具體需求，我可以再調整程式。
