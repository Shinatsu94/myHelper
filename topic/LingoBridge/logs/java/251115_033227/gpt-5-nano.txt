82

建議改進：使用實作完整的下三角形二維陣列並加上清楚的註解與可讀性更高的變數命名，並在邊界條件處理更嚴謹。

改進說明與評分要點
- 正確性（50%）
  - 原作雖能在給定樣本輸出正確結果，但未真正建立並使用完整的下三角形二維陣列，對題目「建立完整的下三角形二維陣列」的要求較薄。改用完整的二維陣列填值後，能更符合題意並讓日後維護更容易。評分：40/50
- 邏輯（30%）
  - 原作邏輯直觀且穩定，但效率較低且未明確中斷外層迴圈；改用完整陣列配合雙迴圈搜尋，並使用標籤中斷可提升魯棒性與可閱讀性。評分：28/30
- 格式（10%）
  - 原作註解較少，命名與格式略顯雜亂，且檔案與類別名稱未明確對齊。改用較清晰的命名與完整註解，提升可讀性。評分：7/10
- 備註（10%）
  - 原作有程式頭註解，但與檔名/類別名尚未一致，且未標註日期等。改進後補充清晰註解並確保檔案結構一致。評分：7/10

修改後的程式說明
- 使用 2D 陣列 tri[n][n]，只在下三角區塊填入遞增的數字，其他位置保留默認值。
- 於找到目標值時，使用雙迴圈掃描並在找到時立即輸出位置，未找到則輸出相應訊息。
- 將類別名稱改為與檔案名相符（LowerTriangularSearch），並加入完整的檔案註解與清晰的變數命名，增加可讀性與維護性。
- 使用 Scanner 進行輸入並在結束時關閉資源。

修改後的完整程式碼
```java
/*
 * 檔案名稱: LowerTriangularSearch.java
 * 功能: 建立下三角形二維陣列，尋找特定數字的位置
 * 作者: 你的名字
 * 日期: 2025-11-14
 * 說明: 讀入高度 n，建立下三角形矩陣 tri[n][n]，其下三角元素按順序填入 1..n(n+1)/2，
 *       找出使用者指定的數字 target 的位置，輸出格式為 target[row, col]（row與col皆為 1-based）。
 */

import java.util.Scanner;

public class LowerTriangularSearch {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        int n;
        int target;

        // 讀取高度與要尋找的數字
        if (in.hasNextInt()) {
            n = in.nextInt();
        } else {
            in.close();
            return;
        }

        if (in.hasNextInt()) {
            target = in.nextInt();
        } else {
            in.close();
            return;
        }

        // 建立下三角形矩陣並填入數字
        int[][] tri = new int[n][n];
        int value = 1;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j <= i; j++) {
                tri[i][j] = value++;
            }
        }

        // 搜尋 target 的位置
        int foundRow = -1;
        int foundCol = -1;
        outer:
        for (int i = 0; i < n; i++) {
            for (int j = 0; j <= i; j++) {
                if (tri[i][j] == target) {
                    foundRow = i;
                    foundCol = j;
                    break outer;
                }
            }
        }

        if (foundRow == -1) {
            System.out.printf("not find %d in array.", target);
        } else {
            // 輸出為 1-based 的行列
            System.out.printf("%d[%d, %d]", target, foundRow + 1, foundCol + 1);
        }

        in.close();
    }
}
```
