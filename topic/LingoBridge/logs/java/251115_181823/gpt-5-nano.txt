98

改進建議：可使用單一累積迴圈自動輸出各階段的近似值，並在找尋最小 i 時持續累加提升效率，同時保留原有輸出格式。

修改說明與重點
- 將兩個區段合併成一個自 1 到 100000 的單一累積過程，逐次累加項，並在每到 10000 的倍數時輸出 pi 的近似值，避免對每個 i 重新從頭計算，提升效率。
- 在累積過程結束後，從 100000 開始繼續累加直到找到最小的 i，使 pi 值在小數點第 5 位等於 3.14159 的條件成立，並以相同的輸出格式輸出結束結果。
- 輸出格式保持不變：i 使用寬度 6 的格式輸出，pi 使用小數點後 10 位，並在必要處留出空行以符合題意的排版。
- 程式內容加入清晰註解，維持原作檔案名稱與作者資訊的風格。

修改後完整程式碼
public class CSIE_41343240_1017_1 {
    //date: 2025/10/17
    //function: 計算 π 的近似值，並找出最小的項數 i，使 π 的值在小數點第 5 位精確到 3.14159。
    //name&number: 黃榮裕41343240
    public static void main(String[] args) {
        // (a) 使用單一累積迴圈，輸出 i = 10000, 20000, ..., 100000 的 pi 近似值
        final int maxI = 100000;
        double sum = 0.0; // 累積的 ∑_{k=1..i} (-1)^(k-1) / (2k-1)
        for (int k = 1; k <= maxI; k++) {
            double term = ((k & 1) == 1) ? (1.0 / (2 * k - 1)) : (-1.0 / (2 * k - 1));
            sum += term;
            if (k % 10000 == 0) {
                double piValue = 4.0 * sum;
                System.out.printf("i = %6d, pi = %.10f\n", k, piValue);
            }
        }

        // (b) 找到最小的 i 使 pi 的近似值到小數點第 5 位為 3.14159
        int i = maxI;
        while (true) {
            i++;
            double term = ((i & 1) == 1) ? (1.0 / (2 * i - 1)) : (-1.0 / (2 * i - 1));
            sum += term;
            double piValue = 4.0 * sum;
            if ((int) (piValue * 100000.0) == 314159) { // 取到小數點第5位比對
                System.out.printf("\ni = %d\n", i);
                break;
            }
        }
    }
}
