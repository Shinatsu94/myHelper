12

評分細節：
- 正確性（50%）：0/50
  - 程式未解題，未計算 pi 的近似值，也未完成題目需求中的輸出格式。
- 邏輯（30%）：0/30
  - 程式邏輯與題意嚴重不符，無法呈現所需的序列計算與最小 i 的判定。
- 格式（10%）：6/10
  - 程式有基本的縮排與結構，但命名與排版不一致，缺乏統一風格與適當的註解。
- 備註（10%）：6/10
  - 有作者與學號的標頭註解，但缺少檔案名稱、功能說明、日期等完整註解，以及程式內容的說明。

修改說明與優化重點
- 取代原有與題意完全不相關的邏輯，改寫為完整的 Leibniz 公式近似計算，符合題目要求的輸出格式。
- 使用逐步累加的方式計算 pi 的近似值，避免每次都重新從頭計算，提高效率。
- 對於輸出格式，採用格式化輸出，確保 i 為六位數寬度對齊，pi 顯示十位小數，並符合題目給定的換行與空白規範。
- 新增分段輸出：先輸出 i=10000 到 100000 之間每 10000 的 pi 值，接著輸出找到的最小 i 使 pi >= 3.14159 的值，兩段之間留一空行。
- 加入清晰的程式註解與標頭，說明檔案名稱、功能與日期，提升可維護性。

修改後完整程式碼（可直接編譯執行）：
/*
File: LeibnizPi.java
Description: 使用 Leibniz 公式近似 pi，輸出 i = 10000 至 100000 (步階 10000) 的 pi 值，並找出最小的 i 使 pi >= 3.14159。
Author: 自動評分示例
Date: 2025-11-12
*/
public class Main {
    public static void main(String[] args) {
        // Part (a): i 為 10000, 20000, ..., 100000，輸出 pi 值，格式為 i = 6位寬, pi = 10位小數
        double sum = 0.0;
        for (int i = 1; i <= 100000; i++) {
            int sign = (i % 2 == 1) ? 1 : -1;
            sum += sign / (double)(2 * i - 1);
            if (i % 10000 == 0) {
                double pi = 4.0 * sum;
                System.out.printf("i = %6d, pi = %.10f%n", i, pi);
            }
        }

        // Part (b): 找到最小的 i 使 pi >= 3.14159
        sum = 0.0;
        int iTarget = 0;
        for (int i = 1; ; i++) {
            int sign = (i % 2 == 1) ? 1 : -1;
            sum += sign / (double)(2 * i - 1);
            double pi = 4.0 * sum;
            if (pi >= 3.14159) {
                iTarget = i;
                break;
            }
        }

        // 空行分隔兩部分輸出
        System.out.println();
        System.out.println("i = " + iTarget);
    }
}

修改原因說明
- 重新實作成符合題意的 Lehiz 近似計算，避免原程式與題目內容嚴重不符的情況。
- 優化計算方式，使用逐步累加避免重複計算，提升效能。
- 輸出格式嚴格遵循題目要求，確保輸出與評分標準一致。

一句話改進建議
- 若要提升可讀性與可維護性，建議將計算與輸出分成函式（如 computePi(int terms) 與 findMinIForPi(double target)），並加入完整的程式註解與例外處理。
