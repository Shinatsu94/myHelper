19

評分明細
- 正確性: 0/50
- 邏輯: 0/30
- 格式: 9/10
- 備註: 10/10

修改後完整程式碼（Java）
/*
檔案名稱: LeibnizPi.java
功能: 使用莱布尼茗斯公式計算 pi 的近似值。輸出 i = 10000, 20000, ..., 100000 對應的 pi 值（pi 保留小數點後10位，i 顯示為6位寬度），並找出使 pi >= 3.14159 的最小 i，另外輸出該 i。
作者: 輸入者（學生姓名或編號）
日期: 2025-11-11
說明: 本程式採用逐步累加的方式，避免重新計算整個序列，提高效率；同時符合題目要求的輸出格式。
*/
public class LeibnizPi {
    public static void main(String[] args) {
        // 逐步累加的方式，先輸出 i = 10000, 20000, ..., 100000 對應的 pi 值
        int[] targets = {10000, 20000, 30000, 40000, 50000,
                         60000, 70000, 80000, 90000, 100000};

        double sum = 0.0;
        int idx = 0; // 已計算的項數（k 的個數，對應到 i 為 idx）
        for (int target : targets) {
            while (idx < target) {
                // 第 idx 項的符號：idx 為偶數時為 +，奇數時為 -
                sum += ((idx % 2 == 0) ? 1.0 : -1.0) / (2.0 * idx + 1.0);
                idx++;
            }
            double pi = 4.0 * sum;
            System.out.printf("i = %6d, pi = %.10f%n", target, pi);
        }

        // Part (b): 找出最小的 i 使 pi ≥ 3.14159
        // 從當前 idx 及 sum 繼續累加，直到 pi ≥ 3.14159
        while (true) {
            sum += ((idx % 2 == 0) ? 1.0 : -1.0) / (2.0 * idx + 1.0);
            idx++;
            double pi = 4.0 * sum;
            if (pi >= 3.14159) {
                System.out.println("i = " + idx);
                break;
            }
        }
    }
}

修改說明與原因
- 重新設計核心算法：改用逐步累加的方式計算莱布尼茗斯公式，能在輸出每個指定 i 值時直接得到對應的 pi，並避免重複計算整個序列，提高效率與穩定性。
- 輸出格式調整：使用 System.out.printf("i = %6d, pi = %.10f%n", …) 以滿足題目要求的 i 顯示寬度與 pi 小數位數，同時利用格式化使輸出對齊美觀。
- 程式結構與可讀性提升：加入說明性註解、使用易懂變數名稱、並提供完整的檔案標頭註解，符合題目對格式與註解的要求。
- 增加額外功能：補足 part (b) 的需求，找出讓 pi ≥ 3.14159 的最小 i，並輸出該值，全面覆蓋題目兩部分。

改進建議或反饋
- 建議在正式提交前，先逐步用小數量的 i 做驗證，以確保輸出格式與數值精度符合要求，避免格式或四捨五入造成的差異。
