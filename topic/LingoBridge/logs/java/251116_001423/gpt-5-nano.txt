86

建議改進：此作法在數字範圍內正確，但若規模增大或需要更清晰的可維護性，建議改用動態規劃/組合數學方式計算，並加入程式標頭註解以符合格式要求。

修改說明與理由
- 使用動態規劃計算五位數（可視為帶前導零的 00000-99999）的各位數和分布，再加上 100000 的特殊情況，避免逐個暴力枚舉，提升可讀性與擴展性。
- 加入檔案標頭註解，說明檔案名稱、功能、作者、日期等，提升格式與可維護性。
- 改善變數命名與結構，使程式邏輯更清晰，便於他人閱讀與維護。
- 使用較安全的 I/O 方式與型別 (長整數長度，避免溢位風險)，並對極端輸入做適當處理。

改寫後完整程式碼
/*
檔案名稱: CSIE_41343234_1003_3_DP.java
功能: 計算 1~100000 之間，數字各位數字總和等於輸入 A 的個數
作者: 設定為教授
日期: 2025-11-15
*/

import java.io.BufferedReader;
import java.io.InputStreamReader;

public class CSIE_41343234_1003_3_DP {
    public static void main(String[] args) {
        try {
            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
            String line = br.readLine();
            int A = Integer.parseInt(line.trim());

            // dp[s] 表示在五位數字（包含前導零）的情況下，總和為 s 的序列數量
            int[] dp = new int[46]; // 最大總和為 5 * 9 = 45
            dp[0] = 1;

            // 對五位數字逐位累加，考慮每位數字 d 取 0..9
            for (int pos = 0; pos < 5; pos++) {
                int[] next = new int[46];
                for (int s = 0; s <= 45; s++) {
                    if (dp[s] == 0) continue;
                    for (int d = 0; d <= 9; d++) {
                        if (s + d <= 45) {
                            next[s + d] += dp[s];
                        }
                    }
                }
                dp = next;
            }

            long ans = 0;
            if (A == 0) {
                // 00000 的和為 0，但數字範圍為 1..99999，因此需要排除 00000
                ans = dp[0] - 1;
            } else if (A == 1) {
                // 1 的情況：5 位數字中總和為 1 的有 dp[1] 個，加上 100000 的情況
                ans = dp[1] + 1;
            } else if (A >= 2 && A <= 45) {
                ans = dp[A];
            } else {
                // A 超出可能的總和範圍，結果為 0
                ans = 0;
            }

            System.out.println(ans);
        } catch (Exception e) {
            // 輸入異常時，輸出 0 作為保底處理
            System.out.println(0);
        }
    }
}
