7

以下依據您的標準對學生的作業進行評分與回饋，並提供修改後的完整程式碼與修改說明。

評分細項
- 正確性（50%）：0
  - 作業需求為利用 Leh-nyz-Leibniz 公式近似 pi，輸出 i=10000,20000,...,100000 共十組結果，且顯示 i 至六位、pi 至小數點後十位，另外求出最小的 i 使 pi 的近似值落在 3.14159 的容許範圍內。學生程式僅做整數反轉，與題意無關，未產生預期輸出，故正確性為 0。
- 邏輯（30%）：5
  - 學生程式有自定函式與 main 主流程，但與題意嚴重脫節，邏輯結構本身是可運作的反轉功能，僅是解題邏輯錯置，因此給予有限的邏輯分數。
- 格式（10%）：2
  - 程式碼有基本縮排與命名，但檔案名稱與整體可讀性較差，缺乏一致性與清晰註解，符合最小可讀性需求，故給 2 分。
- 備註（10%）：0
  - 欠缺程式標頭註解（檔案名稱、功能、作者、日期等說明），未達備註要求，給 0 分。

總結得到的分數：7

修改說明與修改後程式碼
修改原因與內容要點
- 說明問題：原作業需求並非反轉輸入，而是以 Leh-nyz-Leibniz 公式來近似圓周率，並輸出指定格式的結果。
- 改善措施：
  - 移除與題意無關的 reverseNumber 函式與相關輸入輸出。
  - 實作一個累積式的近似計算：用 4 ∑_{k=1..i} (-1)^{k+1} /(2k-1) 的逐步累加方式，從 i=1 累加到 i=100000，並在 i=10000、20000、...、100000 時輸出對應的 pi 值，格式符合題目要求（i 以六位寬度對齊、pi 取十位小數）。
  - 為部分 (b) 的需求，額外加入搜尋機制，找出最小的 i 使 pi 的近似值落在 3.14159 的容忍範圍內（以誤差 < 0.00001 為條件），並輸出該 i。
  - 加上完整的程式標頭註解，提升程式可讀性與維護性。
  - 使用清楚的變數命名與適當的註解，提升可讀性與格式規範。

修改後完整程式碼
（請以純文字閱讀，程式可直接於 Java 環境執行）

/**
 * File: LeibnizPi.java
 * 功能: 使用Leibniz級數近似 pi，輸出 i=10000, 20000, ..., 100000 時的 pi 值，pi 格式為小數點後10位，
 *       i 顯示為六位數寬度，並於最後輸出使近似值落在 pi = 3.14159 之最小 i。
 * 作者: 你
 * 日期: 2025-11-11
 */

public class LeibnizPi {
    public static void main(String[] args) {
        // 部分 (a): 逐步累加 Leh-nyz-Leibniz 公式並輸出指定 i 的結果
        double sum = 0.0;
        int maxPrintI = 100000;
        for (int i = 1; i <= maxPrintI; i++) {
            double term = ((i % 2 == 1) ? 1.0 : -1.0) / (2.0 * i - 1.0);
            sum += term;
            double pi = 4.0 * sum;
            if (i % 10000 == 0) {
                // i 為六位寬度，pi 保留十位小數
                System.out.println("i = " + String.format("%6d", i) +
                                   ", pi = " + String.format("%.10f", pi));
            }
        }

        // 部分 (b): 找出最小的 i 使 pi 接近 3.14159（誤差小於 0.00001）
        sum = 0.0;
        int iMin = -1;
        double target = 3.14159;
        double tolerance = 0.00001;
        // 設定合理的上限，避免無限迴圈
        for (int i = 1; i <= 1000000; i++) {
            sum += ((i % 2 == 1) ? 1.0 : -1.0) / (2.0 * i - 1.0);
            double pi = 4.0 * sum;
            if (Math.abs(pi - target) < tolerance) {
                iMin = i;
                break;
            }
        }
        System.out.println("i = " + iMin);
    }
}

修改部分說明
- 移除了原先與題意無關的関數 reverseNumber 與反轉輸入的邏輯。
- 新增了對 Leh-nyz-Leibniz 公式的逐步累加與輸出邏輯，確保輸出格式與題目要求一致。
- 新增了尋找最小 i 的邏輯，並輸出 i 的值，符合題目的第二部分需求。
- 增加了檔案標頭註解，提供檔案名稱、功能、作者、日期等資訊，提升可維護性。

一句話改進建議
- 建議在正式提交前補上完整的註解與測試案例，並將輸入輸出行為與格式穩定化（例如用常數定義輸出步階、容忍度等），以降低格式與數值不一致的風險。

如需進一步的說明或測試案例，我可以再提供對應的單元測試與不同浮點容忍度下的輸出樣本。
