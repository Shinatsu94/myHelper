6

改進建議：原作並未實作題目要求的「將陣列每一位元替換為其右側元素的最大值，最後一個為 -1，並輸出結果」的功能，需改用右向掃描並正確處理輸入輸出。

修改內容與原因：
- 正確功能實作：改用從右向左的單次掃描，維護右側的最大值，最後一個元素設為 -1，符合題意且時間複雜度為 O(n)。
- 程式結構與可讀性：重新命名成 RightMaxReplacement，加入合理的標頭註解，提升可維護性。
- 輸入輸出穩健性：使用 Scanner 讀取 n 與 n 個整數，並以空格分隔輸出結果，處理負數輸入。
- 格式與註解：保持適當縮排與清楚的註解說明每段邏輯，提升未來閱讀性。

修改後完整程式碼：
/*
 * File: RightMaxReplacement.java
 * 功能: 對任意長度整數陣列，將每個元素替換為其右側元素的最大值；最後一個元素設為 -1，輸出結果
 * 作者: 你可以填放自己的名字
 * 日期: 2025-11-14
 * 版本: 1.0
 */

import java.util.Scanner;

public class RightMaxReplacement {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        // 讀取陣列長度
        if (!sc.hasNextInt()) {
            sc.close();
            return;
        }
        int n = sc.nextInt();

        int[] arr = new int[n];
        // 讀取陣列元素
        for (int i = 0; i < n; i++) {
            if (sc.hasNextInt()) {
                arr[i] = sc.nextInt();
            } else {
                arr[i] = 0; // 若輸入不足，預設為 0
            }
        }

        // 從右向左處理：最後一個設為 -1，其餘皆為右側的最大值
        if (n > 0) {
            int rightMax = arr[n - 1];
            arr[n - 1] = -1;
            for (int i = n - 2; i >= 0; i--) {
                int current = arr[i]; // 保存原值，避免被覆寫
                arr[i] = rightMax;
                if (current > rightMax) {
                    rightMax = current;
                }
            }
        }

        // 輸出結果，元素以空格分隔
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < n; i++) {
            if (i > 0) sb.append(' ');
            sb.append(arr[i]);
        }
        System.out.println(sb.toString());

        sc.close();
    }
}
