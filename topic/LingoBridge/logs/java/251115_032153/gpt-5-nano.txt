89

建議：建議加入程式標頭註解並將核心邏輯模組化以提升可讀性與維護性。

修改與改進說明：
- 加入完整的程式標頭註解（檔案名稱、功能、作者、日期），符合要求的備註條件。
- 將核心邏輯拆分為獨立方法 buildLowerTriangular 與 locate，提升可讀性、可測試性與重用性。
- 使用 try-with-resources 管理 Scanner，避免資源洩漏。
- 搜尋結果回傳一個 1-based 的位置，與輸出格式保持一致，且若未找到回傳 null，統一輸出提示訊息。
- 程式整體風格與命名更具可讀性，方便日後維護與擴充。

修改後完整程式碼：
/*
File: Main.java
功能: 建立下三角形二維陣列，並找出指定數字的位置
作者: 你的姓名
日期: 2025-11-14
*/
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        try (Scanner sc = new Scanner(System.in)) {
            int n = sc.nextInt();
            int target = sc.nextInt();

            int[][] tri = buildLowerTriangular(n);
            int[] pos = locate(tri, target);

            if (pos != null) {
                System.out.println(target + "[" + pos[0] + ", " + pos[1] + "]");
            } else {
                System.out.println("not find " + target + " in array.");
            }
        }
    }

    // 建立一個下三角形的二維不規則陣列，內容從 1 開始遞增
    private static int[][] buildLowerTriangular(int n) {
        int[][] a = new int[n][];
        int val = 1;
        for (int i = 0; i < n; i++) {
            a[i] = new int[i + 1];
            for (int j = 0; j <= i; j++) {
                a[i][j] = val++;
            }
        }
        return a;
    }

    // 在下三角陣列中尋找 target，若找到回傳 1-based 的 {row, column}，否則回傳 null
    private static int[] locate(int[][] tri, int target) {
        for (int i = 0; i < tri.length; i++) {
            for (int j = 0; j < tri[i].length; j++) {
                if (tri[i][j] == target) {
                    return new int[]{i + 1, j + 1}; // 轉為 1-based
                }
            }
        }
        return null;
    }
}
