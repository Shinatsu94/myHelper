8

- 正確性（50%）：0/50
- 邏輯（30%）：0/30
- 格式（10%）：8/10
- 備註（10%）：0/10

說明與修改建議：
- 原學生程式與題目需求嚴重不符，未實作題目所要求的 pi 近似計算與輸出格式，因此正確性與備註分數為零；格式部分因命名與註解尚可接受，因此給予較高分數。
- 修改要點在於：實作正確的 pi 近似演算法、符合題目輸出格式與要求的輸出樣式、並加入適當的程式檔案註解。

修改後完整程式碼與修改原因：
修改內容說明
- 改以 Leiniz/Leibniz 無窮級數近似 pi 值，逐項累加，並在 i 為 10000、20000、...、100000 時輸出 pi 值，符合題目需求。
- 使用自動逐步累加的方式（避免重複計算），提高效率。
- 輸出格式採用 System.out.printf，i 使用寬度6的格式（%6d），pi 使用小數點後10位（%.10f），以符合題目樣式輸出，例如 i =  10000, pi = 3.1414926536。
- 加入檔案註解與必要的直白註解，改善可讀性與維護性。

修改後完整程式碼（Java）：
```java
/**
 * 檔案名稱: LeibnizPi.java
 * 功能說明: 使用 Leiniz 公式近似圓周率 pi，輸出 i 為 10000, 20000, ..., 100000 时的 pi 值。
 * 作者: 你的名字
 * 日期: 2025-11-11
 * 內容註解: 逐項累加 (1 - 1/3 + 1/5 - 1/7 + ... + (-1)^{i-1} / (2i-1))，再乘以 4。
 */
public class LeibnizPi {
    public static void main(String[] args) {
        int maxN = 100000; // 最大的項數
        double sum = 0.0;

        // 逐項累加，當已累到 i 為 10000、20000、...、100000 時輸出
        for (int i = 1; i <= maxN; i++) {
            double term = ((i - 1) % 2 == 0) ? 1.0 : -1.0;
            sum += term / (2.0 * i - 1.0);

            if (i % 10000 == 0) {
                double pi = 4.0 * sum;
                // i 為 6 位數寬，pi 為小數點後 10 位
                System.out.printf("i = %6d, pi = %.10f%n", i, pi);
            }
        }
    }
}
```

修改原因摘要：
- 直接針對題目需求實作，正確計算 pi 值且輸出格式符合題目規範；透過逐項累加提升可讀性與效率，同時提供清晰的程式註解與標頭資訊。

一句話改進建議或反饋：
- 建議在以後的作業中先確定題意，避免實作與題目無關的功能，並在提交前加入完整的程式註解與輸出格式驗證，提升可讀性與評分友善度。
