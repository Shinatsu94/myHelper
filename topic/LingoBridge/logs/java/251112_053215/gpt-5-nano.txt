4

評分與說明
- 正確性 (0/50)：原程式與題目要求完全不相符，未產生 pi 的近似值與指定格式輸出。
- 邏輯 (0/30)：原程式的邏輯與題意毫無關聯，屬於另一個題目（判定數字的位序性），無法回答本題。
- 格式 (4/10)：雖有基本的 Java 程式結構，但命名與註解不足，格式雜亂，與正式作業要求相距甚遠。
- 備註 (0/10)：缺乏檔案標頭、功能說明、作者與日期等註解。
總分：4/100

修改部分與原因
- 全新實作目標需求：重新設計成能計算莱布尼茲級數近似 π，並符合題目給定的輸出格式與輸出順序。
- 漸進計算與效率：使用逐項累加的方式計算第 k 項，避免重複計算，時間複雜度為 O(n)，可直接輸出 i=10000, 20000, ..., 100000 對應的 pi 值。
- 輸出格式對齊：採用 System.out.printf 並以 i 的寬度排版為 6 位，符合「i =  10000, pi = 3.1414926536」的格式；pi 使用固定小數點後 10 位。
- 後續接續計算最小 i：在達到最大 i 之後，繼續累加直到 pi >= 3.14159，輸出該最小 i（範例為 i = 136121），符合題目 (b) 的需求。
- 程式註解與標頭：加入檔案名稱、功能說明、作者與日期等註解，提升可讀性與可維護性。

修改後完整程式碼
/*
檔案名稱: LeibnizPi.java
功能: 使用莱布尼茲級數近似 π，輸出 i=10000,20000,...,100000 對應的 pi 值，並輸出達到 pi>=3.14159 時的最小 i。
作者: 教學用範例
日期: 2025-11-11
*/
public class LeibnizPi {
    public static void main(String[] args) {
        int maxPrintI = 100000;
        double sum = 0.0;
        // k 表示項數，公式為 pi = 4 * sum_{k=1..i} (-1)^{k-1} / (2k-1)
        for (int k = 1; k <= maxPrintI; k++) {
            double term = 1.0 / (2.0 * k - 1.0);
            if ((k & 1) == 1) sum += term;
            else sum -= term;
            if (k % 10000 == 0) {
                double pi = 4.0 * sum;
                System.out.printf("i = %6d, pi = %.10f%n", k, pi);
            }
        }
        // 從 maxPrintI 開始繼續累加，找出 pi >= 3.14159 的最小 i
        int k = maxPrintI;
        while (true) {
            k++;
            double term = 1.0 / (2.0 * k - 1.0);
            if ((k & 1) == 1) sum += term;
            else sum -= term;
            double pi = 4.0 * sum;
            if (pi >= 3.14159) {
                System.out.println("i = " + k);
                break;
            }
            // 安全性：理論上該迭代會收斂到 pi，故不設上限
        }
    }
}

修改說明
- 以漸進累加的方式計算，避免重複運算，提升效率與精度控制。
- 輸出格式調整為符合題目樣式，且在計算 10000、20000、…、100000 的同時輸出 pi 值。
- 增加後續尋找最小 i 的邏輯，符合問題 (b) 的需求，並輸出該 i。

改進建議或反饋（一句話）
建議在正式作業中補充完整的檔案標頭與說明，並加上簡單的單元測試以驗證輸出格式與數值精度的一致性。
