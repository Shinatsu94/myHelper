2

- 正確性: 0/50
- 邏輯: 0/30
- 格式: 2/10
- 備註: 0/10
總分: 2/100

修改說明與建議
- 修改內容與原因
  - 將作業改寫成正確的勒貝格級數計算程式，逐步累加求 pi，並在每個成員數為 10000 的情況輸出 i 與 pi，符合題意的輸出格式與精度需求。
  - 使用可重用的變數命名與適當註解，並以合適的格式輸出 (i 使用寬度6、pi 使用小數點後10位)，與題目提供的輸出格式對齊。
  - 增加尋找最小 i 使 pi≥3.14159 的功能，並在結尾輸出該 i 值，符合題目子題 (b) 的需求。
  - 以迴圈方式逐步累加避免重複計算，提升效能並降低錯誤率；同時避免使用不相關的輸入輸出。
  - 加入檔案註解與說明，提升維護性。

- 修改後完整程式碼（請以 UTF-8 編碼存檔）
// 檔案: LeibnizPi.java
// 功能: 使用勒貝格級數近似 pi，輸出 i = 10000, 20000, ..., 100000 時的 pi 值；再輸出使 pi 至少等於 3.14159 的最小 i
// 作者: 你的教授 / 日期: 2025-11-11
public class LeibnizPi {
    public static void main(String[] args) {
        final int MAX_PRINT_I = 100000; // 只輸出到 i = 100000 的 pi 值
        final int MAX_TOTAL_I = 200000; // 設定總計算到的最大 i
        double sum = 0.0;
        int minimalI = -1;

        for (int k = 0; k < MAX_TOTAL_I; k++) {
            // 第 k 項：(-1)^k / (2k + 1)
            double term = (k % 2 == 0) ? 1.0 : -1.0;
            sum += term / (2.0 * k + 1.0);

            int iVal = k + 1;

            // 輸出 i = 10000, 20000, ..., 100000 的 pi 值
            if (iVal <= MAX_PRINT_I && iVal % 10000 == 0) {
                double pi = 4.0 * sum;
                System.out.printf("i = %6d, pi = %.10f%n", iVal, pi);
            }

            // 找到使 pi ≥ 3.14159 的最小 i
            if (minimalI == -1 && 4.0 * sum >= 3.14159) {
                minimalI = iVal;
            }
        }

        // 輸出使 pi 至少為 3.14159 的最小 i
        if (minimalI != -1) {
            System.out.printf("i = %6d%n", minimalI);
        } else {
            // 理論上不會發生，但作保留的回退
            System.out.printf("i = %6d%n", MAX_TOTAL_I);
        }
    }
}

修改說明要點
- 使用了實作上更正確的逐次累加法，避免先前程式只處理數字與輸出，完全解決原題意中未實作的問題。
- 變數命名改為更具描述性的名稱，並加入註解與標頭，提升可讀性與可維護性。
- 輸出格式嚴格遵循 i 的欄位寬度與 pi 的精度要求（i 6 位、pi 10 位小數）。
- 增加了尋找最小 i 的邏輯，符合題目 (b) 的需求。

改進建議（一句話）
- 建議把核心計算與輸出邏輯分解成函式（例如 createPiSeries、findMinimalI），以提升重用性與測試性，並在主程式中呼叫，方便日後維護與擴充。
