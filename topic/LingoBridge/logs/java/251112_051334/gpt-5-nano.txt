92
- 正確性: 48/50
- 邏輯: 28/30
- 格式: 8/10
- 備註: 8/10

修改後完整程式碼（已優化與整理，符合題目要求的輸出與結構）：
/**
 * 程式名稱 : LeibnizPi
 * 功能說明：使用萊布尼茲級數近似圓周率 pi，輸出指定 i 的結果，並找出使 pi ≈ 3.14159 的最小 i。
 * 日期: 2025/10/03
 * 作者: 張竣傑
 * 學號: 41343224
 */
public class LeibnizPi {
    public static void main(String[] args) {
        double sum = 0.0;        // sum 為 pi/4 的近似值（逐項累加）
        int maxI = 200000;         // 設定上限，保證能找到 i = 136121 的情況
        for (int i = 1; i <= maxI; i++) {
            double term = 1.0 / (2 * i - 1);
            if ((i % 2) == 0) {
                sum -= term;
            } else {
                sum += term;
            }

            // 輸出指定 i 的 pi 值，i 以 6 位數輸出，pi 以小數點後 10 位輸出
            if (i <= 100000 && (i % 10000) == 0) {
                double pi = sum * 4.0;
                System.out.printf("i = %6d, pi = %.10f%n", i, pi);
            }

            // 找到 pi 的近似值等於 3.14159 的最小 i
            long scaled = (long) ((sum * 4.0) * 100000.0); // pi * 100000 的整數部分
            if (scaled == 314159) {
                System.out.printf("i = %6d%n", i);
                break;
            }
        }
    }
}

修改說明與原因：
- 重新命名與整理：將原檔案改名為更具語意的 LeibnizPi，並提供完整、清晰的程式註解與標頭信息，提升可閱讀性與維護性。
- 輸出格式穩定化：使用 System.out.printf 與格式字串，確保 i 顯示為 6 位數、pi 顯示為小數點後 10 位，輸出順序與題目要求一致。
- 結束條件更穩健：改用 scaled = (long)((sum*4.0)*100000) 並判斷是否等於 314159 以判定 pi 是否為 3.14159 的近似值，避免浮點數比較的不穩定與多餘的整數計算變數。
- 可讀性與結構：將符號與邏輯分散到清楚的區塊中，避免不必要的巢狀和混雜的變數，使程式更易於閱讀與維護。

一句話改進建議：
- 建議把輸出需求與判斷條件分離成獨立方法，讓主流程更清晰，並在註解中明確說明輸出格式與判斷條件的邏輯。
