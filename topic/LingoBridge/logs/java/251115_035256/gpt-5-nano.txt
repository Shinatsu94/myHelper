75

改進建議：請在程式中加強對行列式為0的情況處理、統一輸出格式以符合題意（零值直接輸出「0」且每格以單一空格分隔、行尾無多餘空格），並加入程式頭註解提升可讀性與維護性。

修改說明與原因：
- 新增行列式為0的檢查，若矩陣不可逆，輸出友善的訊息並結束，避免除以0造成錯誤或輸出非預期結果。
- 統一輸出格式：所有非零元素以四位小數輸出，零值改為直接輸出字串 "0"，並確保每格之間只有單一空格，行末不留多餘空格，符合題目規範。
- 加入程式頭註解（檔名、功能、作者、日期、說明），提升可讀性。
- 程式結構與變數命名做適當清晰化，並避免使用硬編碼格式，便於維護與未來擴展。

修改後完整程式碼（保持原本類別名稱，並加入改良內容）：

import java.util.Locale;
import java.util.Scanner;

/*
 * 檔名: CSIE_41343208_1031_4.java
 * 功能: 讀取一個 3x3 矩陣，若可逆則輸出其反矩陣；元素顯示為小數點後四位，
 *       零元素直接輸出 "0"；輸出格式為每行三個元素，每個元素以單一空格分隔，無尾端空格。
 * 作者: 教授
 * 日期: 2025-11-14
 * 備註: 未提供反矩陣時輸出提示訊息並結束程式。
 */

public class CSIE_41343208_1031_4 {
    public static void main(String[] args) {
        Locale.setDefault(Locale.US); // 確保小數點為 '.'
        Scanner sc = new Scanner(System.in);

        double[][] a = new double[3][3];

        // 讀入 3x3 矩陣
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                if (sc.hasNextDouble()) {
                    a[i][j] = sc.nextDouble();
                } else {
                    // 若輸入不足，結束程式
                    return;
                }
            }
        }

        // 計算行列式
        double det = a[0][0] * (a[1][1] * a[2][2] - a[2][1] * a[1][2])
                   - a[0][1] * (a[1][0] * a[2][2] - a[2][0] * a[1][2])
                   + a[0][2] * (a[1][0] * a[2][1] - a[2][0] * a[1][1]);

        // 行列式為0，矩陣無反矩陣
        if (Math.abs(det) < 1e-12) {
            System.out.println("此矩陣無反矩陣");
            return;
        }

        // 計算反矩陣（以伴随矩陣 / 行列式計算）
        double[][] inv = new double[3][3];
        inv[0][0] =  (a[1][1] * a[2][2] - a[2][1] * a[1][2]) / det;
        inv[0][1] = -(a[0][1] * a[2][2] - a[2][1] * a[0][2]) / det;
        inv[0][2] =  (a[0][1] * a[1][2] - a[1][1] * a[0][2]) / det;
        inv[1][0] = -(a[1][0] * a[2][2] - a[2][0] * a[1][2]) / det;
        inv[1][1] =  (a[0][0] * a[2][2] - a[2][0] * a[0][2]) / det;
        inv[1][2] = -(a[0][0] * a[1][2] - a[1][0] * a[0][2]) / det;
        inv[2][0] =  (a[1][0] * a[2][1] - a[2][0] * a[1][1]) / det;
        inv[2][1] = -(a[0][0] * a[2][1] - a[2][0] * a[0][1]) / det;
        inv[2][2] =  (a[0][0] * a[1][1] - a[1][0] * a[0][1]) / det;

        // 輸出反矩陣，符合題意格式
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                double v = inv[i][j];
                String token;
                // 若值被視為近似零，輸出 "0"
                if (Math.abs(v) < 1e-9) {
                    token = "0";
                } else {
                    token = String.format(java.util.Locale.US, "%.4f", v);
                }
                System.out.print(token);
                if (j < 2) System.out.print(" ");
            }
            // 每行結束換行
            System.out.println();
        }
    }
}
