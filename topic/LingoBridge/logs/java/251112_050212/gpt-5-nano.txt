87

修改後程式碼（完整）
public class CSIE_41343128_1017_1 {
    /*
     檔案名稱: CSIE_41343128_1017_1.java
     功能: (a) 輸出 i 從 10000 到 100000（每次增量為 10000）對應的 pi 值；
           (b) 找出最小的 i，使 pi 四捨五入至小數點第 5 位等於 3.14159。
     作者: 陳廷鑫
     日期: 2025-11-11
     說明: 以單一循環同時計算兩個需求，並在需要時輸出格式化結果。
    */
    public static void main(String[] args) {
        final int MAX_I = 100000;
        double sum = 0.0;     // Leibniz 公式的正負項和：sum = 1 - 1/3 + 1/5 - 1/7 + ...
        int sign = 1;           // 1 表示加項，-1 表示減項
        int minIForPi = -1;     // 儲存符合 pi ~ 3.14159 條件的最小 i

        for (int i = 1; i <= MAX_I; i++) {
            sum += sign * (1.0 / (2 * i - 1));
            sign = -sign;

            // (a) 每 10000 項輸出一次 pi 值
            if (i % 10000 == 0) {
                double pi = sum * 4.0;
                System.out.printf("i = %6d, pi = %.10f\n", i, pi);
            }

            // (b) 找出最小 i 使 pi 四捨五入至 3.14159
            if (minIForPi == -1) {
                double piVal = sum * 4.0;
                // 將 pi 四捨五入到小數第5位後等於 3.14159 的區間
                if (piVal >= 3.141585 && piVal < 3.141595) {
                    minIForPi = i;
                }
            }
        }

        System.out.println();
        // 輸出最小的 i（6 位元寬度顯示）
        System.out.printf("i = %6d\n", minIForPi);
    }
}

修改原因與說明
- 效率提升：原程式對於每一個 i 都重新從 a=1 累加到 i，時間複雜度為 O(n^2)（相對於最大 i），但實際需求僅需累加到 MAX_I 即可並在每個 10000 的點輸出。因此改為單一次循環，逐步累加到 MAX_I，達成 O(n) 的效率，並維持相同輸出結果。
- 可讀性與維護性提升：統一使用單一變數 sum 及 sign 來表示當前的級數和與符號，讓邏輯更清晰，並在循環中同時完成兩個需求（a 與 b）的輸出與判斷。
- 輸出格式穩定性：改用 System.out.printf 並維持 i 的欄位寬度為六，以符合題目對齊與格式的要求；最後輸出 i 的最小值時也以相同的格式輸出，確保一致性。
- 註解與標頭：增添檔案標頭註解，描述檔案功能、作者與日期，符合作業要求中的註解與檔案說明需求。

一句話改進建議
建議再加上單元測試或自動化驗證，並在輸出前對浮點不確定性做更嚴謹的處理（例如用高精度類別或穩健的四捨五入策略），以提升結果的穩定性與可追蹤性。
