24

建議：把輸出改為符合題意的格式，僅輸出 3×3 的反矩陣，元素四位小數；遇到值為 0 的元素直接輸出 0；移除不必要的矩陣式與標示文字，並使用二維陣列與清晰的函式分工提升可讀性與可維護性。

修改重點與原因
- 使用二維陣列取代九個獨立變數，提升可讀性與維護性。
- 輸出格式改為四位小數，並對零值採用閾值處理，遇到近似為 0 的數值避免輸出成 -0.0000。
- 移除原程式的多餘輸出（行列式值與說明文字），嚴格符合題目輸出格式。
- 拆分成輔助方法（det3、invert3x3），使主流程更清晰。
- 加入檔案頭註解與合理變數命名，提升格式性與可讀性。

修改後完整程式碼
```java
import java.util.Locale;
import java.util.Scanner;

public class MatrixInverse3x3 {
    /*
     * 文件名稱: MatrixInverse3x3.java
     * 功能: 讀入 3x3 矩陣，輸出其反矩陣，元素以四位小數輸出；若元素為 0，直接輸出 0。
     * 作者: 謝老師（示例）
     * 日期: 2025-11-14
     */

    public static void main(String[] args) {
        Locale.setDefault(Locale.US); // 確保小數點為 '.'
        Scanner sc = new Scanner(System.in);

        // 讀入 3x3 矩陣
        double[][] A = new double[3][3];
        for (int r = 0; r < 3; r++) {
            for (int c = 0; c < 3; c++) {
                if (!sc.hasNextDouble()) {
                    System.err.println("輸入格式錯誤：請輸入 9 個數字。");
                    sc.close();
                    return;
                }
                A[r][c] = sc.nextDouble();
            }
        }
        sc.close();

        // 計算行列式
        double det = det3(A);
        double EPS = 1e-12;
        if (Math.abs(det) < EPS) {
            System.err.println("矩陣不可逆：行列式近似為 0。");
            return;
        }

        // 計算反矩陣
        double[][] inv = invert3x3(A, det);

        // 輸出 A^{-1}，格式為三行，每行三個數，值為 0 時輸出 0，其他採四位小數
        for (int r = 0; r < 3; r++) {
            for (int c = 0; c < 3; c++) {
                double val = inv[r][c];
                String out;
                if (Math.abs(val) < 0.00005) {
                    out = "0";
                } else {
                    out = String.format(Locale.US, "%.4f", val);
                }
                System.out.print(out);
                if (c < 2) System.out.print(" ");
            }
            if (r < 2) System.out.println();
        }
    }

    // 計算 3x3 矩陣的行列式
    private static double det3(double[][] M) {
        return M[0][0] * (M[1][1] * M[2][2] - M[1][2] * M[2][1])
             - M[0][1] * (M[1][0] * M[2][2] - M[1][2] * M[2][0])
             + M[0][2] * (M[1][0] * M[2][1] - M[1][1] * M[2][0]);
    }

    // 計算 3x3 矩陣的反矩陣
    private static double[][] invert3x3(double[][] M, double det) {
        double a = M[0][0], b = M[0][1], c = M[0][2];
        double d = M[1][0], e = M[1][1], f = M[1][2];
        double g = M[2][0], h = M[2][1], k = M[2][2];

        // 計算餘子式矩陣 Cofactor
        double C00 =  e * k - f * h;
        double C01 = -(d * k - f * g);
        double C02 =  d * h - e * g;

        double C10 = -(b * k - c * h);
        double C11 =  a * k - c * g;
        double C12 = -(a * h - b * g);

        double C20 =  b * f - c * e;
        double C21 = -(a * f - c * d);
        double C22 =  a * e - b * d;

        // adj(A) = transpose(Cofactor), 然後除以 det
        double[][] inv = new double[3][3];
        inv[0][0] = C00 / det;
        inv[0][1] = C10 / det;
        inv[0][2] = C20 / det;

        inv[1][0] = C01 / det;
        inv[1][1] = C11 / det;
        inv[1][2] = C21 / det;

        inv[2][0] = C02 / det;
        inv[2][1] = C12 / det;
        inv[2][2] = C22 / det;

        return inv;
    }
}
```
