2
- 正確性: 0/50
- 邏輯: 0/30
- 格式: 2/10
- 備註: 0/10

評估摘要與建議
- 原有程式完全不符合題意，僅做數字反轉，缺乏對 pi 的計算與輸出格式要求的實作。
- 建議的改進方向是：實作莱布尼茲級數求 pi，輸出符合題目格式，並補上必要的程式註解與標頭。

修改後的完整程式碼與說明
修改說明要點：
- 改為完整實作：計算 pi = 4*sum_{k=0}^{n-1} (-1)^k/(2k+1)，對 i=10000,20000,...,100000 分別輸出 pi，且 pi 輸出到小數點後10位，i 輸出至6位寬度，符合題目格式。
- 另外加入一段計算最小的 i 使 pi ≥ 3.14159 的邏輯，並輸出結果 i。
- 加入檔案標頭註解與適當註解，變數命名更具語意，並使用格式化輸出以符合題目要求。
- 程式結構簡短清晰，便於維護與重複使用。

完整程式碼（LeibnizPi.java）：
/*
檔案名稱: LeibnizPi.java
功能說明: 使用莱布尼茲級數近似 π，輸出 i=10000,20000,...,100000 的 pi 值，並找出使 pi≥3.14159 的最小 i。
作者: 教師姓名
日期: 2025-11-12
註解: 程式包含格式化輸出以符合題目要求，並附有程式註解。
*/
import java.util.Locale;

public class LeibnizPi {
    public static void main(String[] args) {
        // (a) 計算 i = 10000, 20000, ..., 100000 的 pi 值
        for (int i = 10000; i <= 100000; i += 10000) {
            double sum = 0.0;
            for (int k = 0; k < i; k++) {
                double term = (k % 2 == 0) ? 1.0 : -1.0;
                sum += term / (2.0 * k + 1.0);
            }
            double pi = 4.0 * sum;
            System.out.printf(Locale.US, "i = %6d, pi = %.10f%n", i, pi);
        }

        System.out.println();

        // (b) 找出最小的 i 使 pi >= 3.14159
        double target = 3.14159;
        double sum = 0.0;
        int minI = 0;
        for (int k = 0; ; k++) {
            double term = (k % 2 == 0) ? 1.0 : -1.0;
            sum += term / (2.0 * k + 1.0);
            double pi = 4.0 * sum;
            minI = k + 1;
            if (pi >= target) {
                break;
            }
            // 安全機制，避免無窮迴圈（理論上不會觸發，因為目標有界，且級數收斂）
            if (k > 1000000) {
                break;
            }
        }
        System.out.println("i = " + String.format(Locale.US, "%6d", minI));
    }
}

修改部分的原因與說明
- 改善點1：改用迴圈逐步累加的方式計算 pi，避免使用者輸入錯誤與不必要的計算步驟，直接輸出需求中的多個結果。
- 改善點2：使用格式化輸出，確保 i 輸出寬度與 pi 小數位數符合題目要求，提升可讀性與一致性。
- 改善點3：增加找出最小 i 使 pi≥3.14159 的邏輯，並以單獨段落輸出，符合題目全部需求。
- 改善點4：加入標頭註解與註解，提升程式可維護性與可理解性，且變數命名更具語意。

一句話改進建議
- 建議把計算邏輯獨立為方法（例如 calcPi(int terms) 與 findMinIForTarget(double target)），以提升可重用性與測試性，同時在主方法中組裝輸出流程。
