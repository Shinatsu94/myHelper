35

修改後完整程式碼與說明如下：

修改後程式碼 (New file: LeibnizPi.java)
（已符合題目要求的輸出格式，使用單個空白分隔、i顯示寬度為6位、pi顯示至小數點後10位；並以單次迭代累加方式提升效率，同時加入找尋使 pi 約為 3.14159 的最小 i 的邏輯。）

/*
 * 檔案名稱: LeibnizPi.java
 * 功能說明: 
 *   - 計算 pi 的近似值 using 公式 pi = 4 * sum_{k=1}^{i} (-1)^{k-1} / (2k-1)
 *   - 輸出 i = 10000, 20000, ..., 100000 對應的 pi 值，保留十位小數
 *   - 找出使 pi 近似值落在 3.14159 的最小 i 並輸出
 * 作者: 你的名字
 * 日期: 2025-11-11
 */

public class LeibnizPi {
    public static void main(String[] args) {
        // Part (a): 逐步累加，輸出 10000 到 100000 每 10000 的 pi 值
        double sum = 0.0;
        int sign = 1;
        final int MAX_FIRST_PART = 100000;
        for (int i = 1; i <= MAX_FIRST_PART; i++) {
            sum += sign * 1.0 / (2 * i - 1);
            sign = -sign;

            if (i % 10000 == 0) {
                double pi = 4.0 * sum;
                System.out.printf("i = %6d, pi = %.10f%n", i, pi);
            }
        }

        // Part (b): 找出使 pi 約等於 3.14159 的最小 i
        // 以 5 位小數四捨五入的方式判斷是否等於 3.14159
        sum = 0.0;
        sign = 1;
        int iFound = -1;
        int maxI = 1000000; // 安全上限，若未找到則以這個值作為回傳
        for (int i = 1; i <= maxI; i++) {
            sum += sign * 1.0 / (2 * i - 1);
            sign = -sign;
            double pi = 4.0 * sum;
            long rounded = Math.round(pi * 1e5); // 轉為 5 位小數後的整數表示
            if (rounded == Math.round(3.14159 * 1e5)) {
                iFound = i;
                break;
            }
        }

        System.out.printf("i = %d%n", iFound);
    }
}

修改原因說明與重點：
- 移除原作業中直接修改迴圈變數的作法（if(j>100000) j=376850），避免對外層 for 迴圈造成不可預期行為與維護困難。
- 以單一累加迴圈來計算 pi，透過 i 的判定在 i 達到 10000、20000、…、100000 時輸出結果，避免重複重新從頭計算，提升效率。
- 輸出格式調整為單空白分隔、i 欄位寬度為 6 位，以符合「i 顯示到6位數」的要求，並將 pi 小數點後 ten 位固定輸出。
- 新增程式標頭註解，說明檔案名稱、功能、作者與日期，提升可讀性與維護性；並在程式中加入適當註解說明程式內容。
- 實作部分使用更清楚的變數命名與結構，提升可讀性；同時保留邏輯清晰的分段（Part (a) 與 Part (b)）。

改進建議（一句話）：建議在實作上分離「輸出區間」與「核心計算」的邏輯，並考慮使用累積和與前一項的變化來避免重複計算，提升可讀性與效率，同時對輸出格式統一遵循題目規範以避免格式差異。
