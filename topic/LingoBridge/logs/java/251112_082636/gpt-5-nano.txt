4

修改結果與評分說明
- 正確性 (50%): 0/50
  - 提交的程式與題目無關，未計算 pia 或輸出指定格式，屬於與題意不符的解法。
- 邏輯 (30%): 0/30
  - 程式邏輯針對「判斷是否為數字的某種排序」而非題目中的勒布尼茲級數近似，與需求完全脫節。
- 格式 (10%): 2/10
  - 程式有完整的結構與括號，但命名較不符合常見慣例（class 名稱小寫、與檔案命名不一定對應），且缺乏題意相關的註解與說明。
- 備註 (10%): 0/10
  - 未提供程式標頭註解、檔案名稱、功能說明、作者與日期等資訊。

修改後完整程式碼
以下提供一份符合題意的「改寫版本」，可輸出指定格式的 pi 近似值，以及找出最小的 i 使 pi >= 3.14159。請保存檔名為 LeibnizPi.java 並以 Java 編譯執行。

/*
 * File: LeibnizPi.java
 * 功能: 計算 pi 的近似值，輸出指定格式的結果，並求出達到 3.14159 的最小項數
 * 作者: 教授姓名
 * 日期: 2025-11-12
 */

public class LeibnizPi {
    public static void main(String[] args) {
        // 1) 逐步計算 i = 10000, 20000, ..., 100000 的 pi 值
        for (int i = 10000; i <= 100000; i += 10000) {
            double sum = 0.0;
            for (int k = 0; k < i; k++) {
                double term = (k % 2 == 0) ? 1.0 : -1.0;
                sum += term / (2 * k + 1);
            }
            double pi = 4.0 * sum;
            System.out.printf("i = %6d, pi = %.10f%n", i, pi);
        }

        // 空行分隔
        System.out.println();

        // 2) 找出最小的 iTerm 使 pi >= 3.14159
        double sum2 = 0.0;
        int terms = 0;
        while (true) {
            double term2 = ((terms % 2 == 0) ? 1.0 : -1.0) / (2 * terms + 1);
            sum2 += term2;
            double currentPi = 4.0 * sum2;
            if (currentPi >= 3.14159) {
                break;
            }
            terms++;
        }
        int minI = terms + 1; // i 總項數
        System.out.printf("i = %d%n", minI);
    }
}

說明修改該部分的原因
- 直接以勒布尼茨級數實作，符合題目對 pi 近似的核心需求，並用迴圈逐步輸出指定 i 值的近似結果與格式。
- 輸出格式採用 printf，確保 i 以寬度6顯示，pi 為小數點後10位，符合題目輸出範例。
- 將「找出最小 i 使 pi ≥ 3.14159」的計算獨立為第二階段，使用逐項累加的方式同樣符合級數的收敛特性，並輸出最小 i。

改進建議或反饋（一句話）
建議將核心演算法模組化為方法、加入註解與錯誤處理，並撰寫單元測試以驗證不同 i 值的輸出與收敛性。
